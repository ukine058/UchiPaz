<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>カスタムパズル</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            user-select: none;
            overflow-x: hidden;
        }

        .container {
            max-width: 400px;
            margin: 0 auto;
            padding: 10px;
            position: relative;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 15px;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            color: white;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .skills-container {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            height: 50px;
        }

        .skill-button {
            flex: 1;
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 10px;
            padding: 5px;
            position: relative;
            overflow: hidden;
        }

        .skill-button:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .skill-button:not(:disabled):hover {
            transform: scale(1.05);
        }

        .skill-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: #00ff00;
            transition: width 0.3s;
        }

        .board {
            width: 100%;
            max-width: 350px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 10px;
            backdrop-filter: blur(10px);
            position: relative;
        }

        .effect-indicator {
            width: 100%;
            max-width: 350px;
            margin: 10px auto 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            text-align: center;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 2px;
            aspect-ratio: 1;
        }

        .cell {
            aspect-ratio: 1;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }

        .cell img {
            pointer-events: none;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .cell:hover {
            transform: scale(1.1);
        }

        .cell.selected {
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            transform: scale(1.1);
        }

        .cell.connected {
            animation: pulse 0.5s ease-in-out;
        }

        .cell.bomb {
            background: radial-gradient(circle, #ff9500, #ff6b00) !important;
            color: white;
            font-weight: bold;
        }

        .cell.special {
            border: 2px solid gold;
            animation: sparkle 1s infinite;
        }

        .cell.removing {
            animation: explode 0.5s ease-out forwards;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #fff;
            border-radius: 50%;
            pointer-events: none;
            animation: particle-burst 0.6s ease-out forwards;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        @keyframes sparkle {
            0%, 100% { box-shadow: 0 0 5px gold; }
            50% { box-shadow: 0 0 15px gold, 0 0 25px gold; }
        }

        @keyframes explode {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.5; }
            100% { transform: scale(0); opacity: 0; }
        }

        @keyframes particle-burst {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0) translate(var(--dx), var(--dy)); }
        }

        @keyframes slideInOut {
            0% { transform: translateX(100%); opacity: 0; }
            10% { transform: translateX(0); opacity: 1; }
            70% { transform: translateX(0); opacity: 1; }
            100% { transform: translateX(-100%); opacity: 0; }
        }

        .menu-button {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 20px;
            cursor: pointer;
            z-index: 1000;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            overflow-y: auto;
        }

        .modal-content {
            background: white;
            margin: 20px auto;
            padding: 20px;
            border-radius: 15px;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }

        .close {
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: #aaa;
        }

        .close:hover {
            color: #000;
        }

        .tab-container {
            display: flex;
            border-bottom: 2px solid #eee;
            margin-bottom: 20px;
        }

        .tab {
            flex: 1;
            padding: 10px;
            background: #f0f0f0;
            border: none;
            cursor: pointer;
            font-weight: bold;
        }

        .tab.active {
            background: #667eea;
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .coordinate-input {
            display: flex;
            gap: 5px;
            align-items: center;
            margin-bottom: 5px;
        }

        .coordinate-input input {
            width: 50px;
        }

        .add-coordinate {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }

        .remove-coordinate {
            background: #f44336;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }

        .button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
        }

        .button:hover {
            background: #5a6fd8;
        }

        .skill-list,
        .panel-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
        }

        .skill-item,
        .panel-item {
            padding: 10px;
            margin-bottom: 10px;
            background: #f9f9f9;
            border-radius: 5px;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .skill-item:hover,
        .panel-item:hover {
            background: #e9e9e9;
        }

        .skill-item.selected,
        .panel-item.selected {
            border-color: #667eea;
            background: #e8f0fe;
        }

        .start-button {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1000;
        }

        .game-over-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 3000;
            align-items: center;
            justify-content: center;
        }

        .game-over-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 300px;
        }

        .color-red { background: #ff6b6b; }
        .color-blue { background: #4ecdc4; }
        .color-green { background: #45b7d1; }
        .color-yellow { background: #f9ca24; }
        .color-purple { background: #a55eea; }
        .color-orange { background: #fd9644; }

        .cutscene {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 5000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .cutscene img {
            max-width: 80%;
            max-height: 80%;
            border-radius: 15px;
            animation: slideInOut 1.2s ease-out forwards;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
            background: #667eea;
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            margin-top: 5px;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .preview-image {
            max-width: 100px;
            max-height: 100px;
            margin-top: 10px;
            border-radius: 5px;
        }

        @media (max-width: 480px) {
            .container {
                padding: 5px;
            }
            
            .modal-content {
                margin: 10px;
                max-width: calc(100% - 20px);
            }
            
            .skill-button {
                font-size: 9px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎮 カスタムパズル</h1>
        </div>
        
        <div class="game-info">
            <div>スコア: <span id="score">0</span></div>
            <div>時間: <span id="time">60</span>s</div>
            <div>チェーン: <span id="chain">0</span></div>
        </div>
        
        <div class="skills-container" id="skillsContainer">
            <!-- スキルボタンがここに動的に生成される -->
        </div>
        
        <div class="board">
            <div class="grid" id="gameBoard">
                <!-- ゲームボードがここに生成される -->
            </div>
        </div>
        <div id="effectIndicator" class="effect-indicator" style="display:none;"></div>
    </div>

    <button class="menu-button" onclick="openModal()">⚙️</button>
    <button class="start-button" id="startButton" onclick="startGame()">ゲーム開始</button>

    <!-- メインモーダル -->
    <div id="mainModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>設定</h2>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            
            <div class="tab-container">
                <button class="tab active" onclick="showTab('skills')">スキル作成</button>
                <button class="tab" onclick="showTab('panels')">特殊パネル</button>
                <button class="tab" onclick="showTab('deck')">デッキ構築</button>
                <button class="tab" onclick="showTab('colors')">色設定</button>
            </div>
            
            <!-- スキル作成タブ -->
            <div id="skillsTab" class="tab-content active">
                <h3>スキル作成</h3>
                <form id="skillForm">
                    <div class="form-group">
                        <label>スキル名:</label>
                        <input type="text" id="skillName" placeholder="スキル名を入力">
                    </div>
                    
                    <div class="form-group">
                        <label>アイコン画像:</label>
                        <div class="file-input-wrapper">
                            <span>ファイルを選択</span>
                            <input type="file" id="skillIcon" accept="image/*" onchange="previewImage(this, 'skillIconPreview')">
                        </div>
                        <img id="skillIconPreview" class="preview-image" style="display:none;">
                    </div>
                    
                    <div class="form-group">
                        <label>カットイン画像:</label>
                        <div class="file-input-wrapper">
                            <span>ファイルを選択</span>
                            <input type="file" id="skillCutscene" accept="image/*" onchange="previewImage(this, 'skillCutscenePreview')">
                        </div>
                        <img id="skillCutscenePreview" class="preview-image" style="display:none;">
                    </div>
                    
                    <div class="form-group">
                        <label>必要消去数:</label>
                        <input type="number" id="requiredCount" min="1" value="10">
                    </div>
                    
                    <div class="form-group">
                        <label>必要な色:</label>
                        <select id="requiredColor">
                            <option value="red">赤</option>
                            <option value="blue">青</option>
                            <option value="green">緑</option>
                            <option value="yellow">黄</option>
                            <option value="purple">紫</option>
                            <option value="orange">オレンジ</option>
                            <option value="any">任意の色</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>消去方法:</label>
                        <select id="clearType" onchange="toggleClearOptions()">
                            <option value="none">なし</option>
                            <option value="coordinates">座標指定</option>
                            <option value="color">色消去</option>
                            <option value="random">ランダム消去</option>
                        </select>
                    </div>
                    
                    <div id="coordinatesSection" class="form-group" style="display:none;">
                        <label>消去座標 (x,y):</label>
                        <div id="clearCoordinates">
                            <div class="coordinate-input">
                                <input type="number" placeholder="x" min="0" max="9">
                                <input type="number" placeholder="y" min="0" max="9">
                                <button type="button" class="remove-coordinate" onclick="removeCoordinate(this)">削除</button>
                            </div>
                        </div>
                        <button type="button" class="add-coordinate" onclick="addClearCoordinate()">座標追加</button>
                    </div>
                    
                    <div id="colorClearSection" class="form-group" style="display:none;">
                        <label>消去する色:</label>
                        <select id="clearColor">
                            <option value="red">赤</option>
                            <option value="blue">青</option>
                            <option value="green">緑</option>
                            <option value="yellow">黄</option>
                            <option value="purple">紫</option>
                            <option value="orange">オレンジ</option>
                        </select>
                        <label>消去個数:</label>
                        <input type="number" id="clearColorCount" min="0" value="5">
                    </div>
                    
                    <div id="randomClearSection" class="form-group" style="display:none;">
                        <label>ランダム消去個数:</label>
                        <input type="number" id="randomClearCount" min="0" value="10">
                    </div>
                    
                    <div class="form-group">
                        <label>生成する特殊パネル:</label>
                        <select id="specialPanel">
                            <option value="">なし</option>
                            <option value="bomb">爆弾</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>特殊パネル生成座標:</label>
                        <div id="specialCoordinates">
                            <div class="coordinate-input">
                                <input type="number" placeholder="x" min="0" max="9">
                                <input type="number" placeholder="y" min="0" max="9">
                                <button type="button" class="remove-coordinate" onclick="removeCoordinate(this)">削除</button>
                            </div>
                        </div>
                        <button type="button" class="add-coordinate" onclick="addSpecialCoordinate()">座標追加</button>
                    </div>
                    
                    <div class="form-group">
                        <label>特殊効果:</label>
                        <select id="specialEffect" onchange="toggleEffectOptions()">
                            <option value="">なし</option>
                            <option value="scoreBoost">スコア上昇</option>
                            <option value="colorBoost">特定色確率上昇</option>
                        </select>
                    </div>
                    
                    <div id="effectOptions" style="display:none;">
                        <div class="form-group">
                            <label>効果時間（手数）:</label>
                            <input type="number" id="effectDuration" min="1" value="5">
                        </div>
                        <div class="form-group">
                            <label>効果値:</label>
                            <input type="number" id="effectValue" min="0" step="0.1" value="2">
                        </div>
                        <div id="colorBoostOptions" class="form-group" style="display:none;">
                            <label>対象色:</label>
                            <select id="boostColor">
                                <option value="red">赤</option>
                                <option value="blue">青</option>
                                <option value="green">緑</option>
                                <option value="yellow">黄</option>
                                <option value="purple">紫</option>
                                <option value="orange">オレンジ</option>
                            </select>
                        </div>
                    </div>
                    
                    <button type="button" class="button" onclick="createSkill()">スキル作成</button>
                </form>
                
                <div class="skill-list" id="skillList">
                    <!-- 作成されたスキルがここに表示される -->
                </div>
            </div>
            
            <!-- 特殊パネル作成タブ -->
            <div id="panelsTab" class="tab-content">
                <h3>特殊パネル作成</h3>
                <form id="panelForm">
                    <div class="form-group">
                        <label>パネル名:</label>
                        <input type="text" id="panelName" placeholder="パネル名を入力">
                    </div>
                    
                    <div class="form-group">
                        <label>パネル画像:</label>
                        <div class="file-input-wrapper">
                            <span>ファイルを選択</span>
                            <input type="file" id="panelImage" accept="image/*" onchange="previewImage(this, 'panelImagePreview')">
                        </div>
                        <img id="panelImagePreview" class="preview-image" style="display:none;">
                    </div>
                    
                    <div class="form-group">
                        <label>基本色:</label>
                        <select id="panelColor">
                            <option value="red">赤</option>
                            <option value="blue">青</option>
                            <option value="green">緑</option>
                            <option value="yellow">黄</option>
                            <option value="purple">紫</option>
                            <option value="orange">オレンジ</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>消去範囲:</label>
                        <div id="panelClearCoordinates">
                            <div class="coordinate-input">
                                <input type="number" placeholder="x" min="-5" max="5">
                                <input type="number" placeholder="y" min="-5" max="5">
                                <button type="button" class="remove-coordinate" onclick="removeCoordinate(this)">削除</button>
                            </div>
                        </div>
                        <button type="button" class="add-coordinate" onclick="addPanelCoordinate()">座標追加</button>
                        <small>相対座標で指定（0,0が自分の位置）</small>
                    </div>
                    
                    <button type="button" class="button" onclick="createPanel()">パネル作成</button>
                </form>
                
                <div class="panel-list" id="panelList">
                    <!-- 作成されたパネルがここに表示される -->
                </div>
            </div>
            
            <!-- デッキ構築タブ -->
            <div id="deckTab" class="tab-content">
                <h3>デッキ構築</h3>
                <p>使用するスキルを選択してください（最大4個）</p>
                <div class="skill-list" id="deckSkillList">
                    <!-- スキル選択リストがここに表示される -->
                </div>
                <button type="button" class="button" onclick="saveDeck()">デッキ保存</button>
            </div>
            
            <!-- 色設定タブ -->
            <div id="colorsTab" class="tab-content">
                <h3>色ごとの画像設定</h3>
                <form id="colorForm">
                    <div class="form-group">
                        <label>赤:</label>
                        <div class="file-input-wrapper">
                            <span>ファイルを選択</span>
                            <input type="file" id="colorRedImage" accept="image/*" onchange="previewImage(this, 'colorRedPreview')">
                        </div>
                        <img id="colorRedPreview" class="preview-image" style="display:none;">
                    </div>
                    <div class="form-group">
                        <label>青:</label>
                        <div class="file-input-wrapper">
                            <span>ファイルを選択</span>
                            <input type="file" id="colorBlueImage" accept="image/*" onchange="previewImage(this, 'colorBluePreview')">
                        </div>
                        <img id="colorBluePreview" class="preview-image" style="display:none;">
                    </div>
                    <div class="form-group">
                        <label>緑:</label>
                        <div class="file-input-wrapper">
                            <span>ファイルを選択</span>
                            <input type="file" id="colorGreenImage" accept="image/*" onchange="previewImage(this, 'colorGreenPreview')">
                        </div>
                        <img id="colorGreenPreview" class="preview-image" style="display:none;">
                    </div>
                    <div class="form-group">
                        <label>黄:</label>
                        <div class="file-input-wrapper">
                            <span>ファイルを選択</span>
                            <input type="file" id="colorYellowImage" accept="image/*" onchange="previewImage(this, 'colorYellowPreview')">
                        </div>
                        <img id="colorYellowPreview" class="preview-image" style="display:none;">
                    </div>
                    <div class="form-group">
                        <label>紫:</label>
                        <div class="file-input-wrapper">
                            <span>ファイルを選択</span>
                            <input type="file" id="colorPurpleImage" accept="image/*" onchange="previewImage(this, 'colorPurplePreview')">
                        </div>
                        <img id="colorPurplePreview" class="preview-image" style="display:none;">
                    </div>
                    <div class="form-group">
                        <label>オレンジ:</label>
                        <div class="file-input-wrapper">
                            <span>ファイルを選択</span>
                            <input type="file" id="colorOrangeImage" accept="image/*" onchange="previewImage(this, 'colorOrangePreview')">
                        </div>
                        <img id="colorOrangePreview" class="preview-image" style="display:none;">
                    </div>
                    <button type="button" class="button" onclick="saveColorImages()">保存</button>
                </form>
            </div>
        </div>
    </div>

    <!-- ゲームオーバーモーダル -->
    <div id="gameOverModal" class="game-over-modal">
        <div class="game-over-content">
            <h2>ゲーム終了！</h2>
            <p>最終スコア: <span id="finalScore">0</span></p>
            <button class="button" onclick="resetGame()">もう一度</button>
        </div>
    </div>

    <!-- カットシーン -->
    <div id="cutscene" class="cutscene">
        <img id="cutsceneImage" src="" alt="スキル発動">
    </div>

    <script>
        // ゲーム状態
        let gameState = {
            board: [],
            score: 0,
            timeLeft: 60,
            chain: 0,
            selectedCells: [],
            isGameActive: false,
            skills: [],
            specialPanels: [],
            activeDeck: [],
            skillCooldowns: {},
            skillProgress: {},
            specialEffects: {},
            gameTimer: null,
            colorImages: {
                red: null,
                blue: null,
                green: null,
                yellow: null,
                purple: null,
                orange: null
            }
        };

        // 色定義
        const colors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange'];
        const colorEmojis = {
            red: '🔴',
            blue: '🔵',
            green: '🟢',
            yellow: '🟡',
            purple: '🟣',
            orange: '🟠'
        };

        // 初期化
        function initGame() {
            createBoard();
            loadData();
            updateSkillButtons();
            updateSpecialPanelOptions();
            fillBoard();
            updateEffectIndicator();
        }

        // ボード作成
        function createBoard() {
            const board = document.getElementById('gameBoard');
            board.innerHTML = '';
            gameState.board = [];
            
            for (let y = 0; y < 10; y++) {
                gameState.board[y] = [];
                for (let x = 0; x < 10; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.addEventListener('mousedown', startSelection);
                    cell.addEventListener('mouseenter', continueSelection);
                    cell.addEventListener('mouseup', endSelection);
                    cell.addEventListener('touchstart', handleTouch);
                    cell.addEventListener('touchmove', handleTouchMove);
                    cell.addEventListener('touchend', handleTouchEnd);
                    board.appendChild(cell);
                    gameState.board[y][x] = null;
                }
            }
        }

        // ボードを埋める
        function fillBoard() {
            for (let y = 0; y < 10; y++) {
                for (let x = 0; x < 10; x++) {
                    if (!gameState.board[y][x] || gameState.board[y][x].type === 'empty') {
                        const colorBoost = gameState.specialEffects.colorBoost;
                        let color;
                        
                        if (colorBoost && Math.random() < 0.5) {
                            color = colorBoost.color;
                        } else {
                            color = colors[Math.floor(Math.random() * colors.length)];
                        }
                        
                        gameState.board[y][x] = {
                            type: 'normal',
                            color: color
                        };
                    }
                }
            }
            updateDisplay();
        }

        // 表示更新
        function updateDisplay() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                const panel = gameState.board[y][x];
                
                cell.innerHTML = '';
                cell.className = 'cell'; // リセット
                if (panel && panel.type !== 'empty') {
                    cell.classList.add(`color-${panel.color}`);
                    if (panel.type === 'bomb') {
                        cell.classList.add('bomb');
                        cell.textContent = '💣';
                    } else if (panel.type === 'special') {
                        cell.classList.add('special');
                        if (panel.imageUrl) {
                            const img = document.createElement('img');
                            img.src = panel.imageUrl;
                            cell.appendChild(img);
                        } else {
                            cell.textContent = panel.emoji || colorEmojis[panel.color];
                        }
                    } else if (gameState.colorImages[panel.color]) {
                        const img = document.createElement('img');
                        img.src = gameState.colorImages[panel.color];
                        cell.appendChild(img);
                    } else {
                        cell.textContent = colorEmojis[panel.color];
                    }
                }
            });
            
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('time').textContent = gameState.timeLeft;
            document.getElementById('chain').textContent = gameState.chain;
            updateEffectIndicator();
        }

        // 特殊効果インジケーター更新
        function updateEffectIndicator() {
            const indicator = document.getElementById('effectIndicator');
            const effects = [];
            
            if (gameState.specialEffects.scoreBoost) {
                effects.push(`スコア${gameState.specialEffects.scoreBoost.multiplier}倍 (${gameState.specialEffects.scoreBoost.duration}ターン)`);
            }
            if (gameState.specialEffects.colorBoost) {
                effects.push(`${gameState.specialEffects.colorBoost.color}出現率UP (${gameState.specialEffects.colorBoost.duration}ターン)`);
            }
            
            if (effects.length > 0) {
                indicator.textContent = effects.join(', ');
                indicator.style.display = 'block';
            } else {
                indicator.style.display = 'none';
            }
        }

        // セル選択処理
        let isSelecting = false;
        let lastSelectedCell = null;

        function startSelection(e) {
            if (!gameState.isGameActive) return;
            
            isSelecting = true;
            gameState.selectedCells = [];
            const cell = e.target.closest('.cell'); // 画像でも親のcellを取得
            if (!cell) return;
            
            const x = parseInt(cell.dataset.x);
            const y = parseInt(cell.dataset.y);
            
            if (gameState.board[y][x] && gameState.board[y][x].type === 'bomb') {
                explodeBomb(x, y);
                return;
            }
            
            if (gameState.board[y][x] && gameState.board[y][x].type === 'special') {
                handleSpecialPanelTap(x, y);
                return;
            }
            
            selectCell(x, y);
            lastSelectedCell = {x, y};
        }

        function continueSelection(e) {
            if (!isSelecting || !gameState.isGameActive) return;
            
            const cell = e.target.closest('.cell'); // 画像でも親のcellを取得
            if (!cell) return;
            
            const x = parseInt(cell.dataset.x);
            const y = parseInt(cell.dataset.y);
            
            if (lastSelectedCell && isAdjacent(lastSelectedCell.x, lastSelectedCell.y, x, y)) {
                const panel = gameState.board[y][x];
                if (panel && panel.type === 'normal' && 
                    (gameState.selectedCells.length === 0 || 
                     gameState.selectedCells[0].color === panel.color)) {
                    selectCell(x, y);
                    lastSelectedCell = {x, y};
                }
            }
        }

        function endSelection() {
            if (!isSelecting || !gameState.isGameActive) return;
            
            isSelecting = false;
            if (gameState.selectedCells.length >= 3) {
                processChain();
            } else {
                clearSelection();
            }
        }

        // タッチイベント処理
        function handleTouch(e) {
            e.preventDefault();
            startSelection({target: e.target.closest('.cell')});
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const element = document.elementFromPoint(touch.clientX, touch.clientY);
            if (element) {
                continueSelection({target: element.closest('.cell')});
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            endSelection();
        }

        // セル選択
        function selectCell(x, y) {
            const panel = gameState.board[y][x];
            if (!panel || panel.type !== 'normal') return;
            
            if (gameState.selectedCells.some(cell => cell.x === x && cell.y === y)) return;
            
            if (gameState.selectedCells.length === 0 || 
                gameState.selectedCells[0].color === panel.color) {
                gameState.selectedCells.push({x, y, color: panel.color});
                const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                cell.classList.add('selected');
            }
        }

        // 隣接チェック
        function isAdjacent(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) <= 1 && Math.abs(y1 - y2) <= 1 && !(x1 === x2 && y1 === y2);
        }

        // 選択解除
        function clearSelection() {
            gameState.selectedCells = [];
            document.querySelectorAll('.cell.selected').forEach(cell => {
                cell.classList.remove('selected');
            });
        }

        // チェーン処理
        function processChain() {
            const chainLength = gameState.selectedCells.length;
            gameState.chain = chainLength;
            
            const removedColors = processRemovePanels(gameState.selectedCells);
            
            setTimeout(() => {
                const baseScore = chainLength * 100;
                const multiplier = gameState.specialEffects.scoreBoost ? gameState.specialEffects.scoreBoost.multiplier : 1;
                gameState.score += Math.floor(baseScore * multiplier);
                
                Object.entries(removedColors).forEach(([color, count]) => {
                    updateSkillProgress(color, count);
                });
                
                if (chainLength >= 6) {
                    const centerCell = gameState.selectedCells[Math.floor(chainLength / 2)];
                    setTimeout(() => {
                        gameState.board[centerCell.y][centerCell.x] = {
                            type: 'bomb',
                            color: 'orange'
                        };
                        updateDisplay();
                    }, 300);
                }
                
                updateSpecialEffects();
                
                setTimeout(() => {
                    dropPanels();
                    fillBoard();
                    clearSelection();
                }, 500);
            }, 300);
        }

        // パネル削除処理
        function processRemovePanels(panels) {
            const removedColors = {};
            const toProcess = [...panels];
            const processed = new Set();
            
            while (toProcess.length > 0) {
                const {x, y} = toProcess.shift();
                if (processed.has(`${x},${y}`)) continue;
                processed.add(`${x},${y}`);
                
                const panel = gameState.board[y][x];
                if (!panel || panel.type === 'empty') continue;
                
                createParticles(x, y);
                const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                cell.classList.add('removing');
                
                if (panel.type === 'special' && panel.clearPattern) {
                    panel.clearPattern.forEach(({x: dx, y: dy}) => {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < 10 && ny >= 0 && ny < 10 && !processed.has(`${nx},${ny}`)) {
                            toProcess.push({x: nx, y: ny});
                        }
                    });
                } else if (panel.type === 'bomb') {
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < 10 && ny >= 0 && ny < 10 && !processed.has(`${nx},${ny}`)) {
                                toProcess.push({x: nx, y: ny});
                            }
                        }
                    }
                }
                
                if (panel.color) {
                    removedColors[panel.color] = (removedColors[panel.color] || 0) + 1;
                }
                
                gameState.board[y][x] = {type: 'empty'};
            }
            
            return removedColors;
        }

        // パーティクル生成
        function createParticles(x, y) {
            const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
            const rect = cell.getBoundingClientRect();
            
            for (let i = 0; i < 5; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = rect.left + rect.width / 2 + 'px';
                particle.style.top = rect.top + rect.height / 2 + 'px';
                particle.style.setProperty('--dx', `${(Math.random() - 0.5) * 100}px`);
                particle.style.setProperty('--dy', `${(Math.random() - 0.5) * 100}px`);
                document.body.appendChild(particle);
                
                setTimeout(() => particle.remove(), 600);
            }
        }

        // パネル落下
        function dropPanels() {
            for (let x = 0; x < 10; x++) {
                let writeIndex = 9;
                for (let y = 9; y >= 0; y--) {
                    if (gameState.board[y][x] && gameState.board[y][x].type !== 'empty') {
                        if (y !== writeIndex) {
                            gameState.board[writeIndex][x] = gameState.board[y][x];
                            gameState.board[y][x] = {type: 'empty'};
                        }
                        writeIndex--;
                    }
                }
            }
        }

        // 爆弾爆発
        function explodeBomb(x, y) {
            const toRemove = [];
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < 10 && ny >= 0 && ny < 10) {
                        toRemove.push({x: nx, y: ny});
                    }
                }
            }
            
            const removedColors = processRemovePanels(toRemove);
            
            setTimeout(() => {
                gameState.score += toRemove.length * 50;
                
                Object.entries(removedColors).forEach(([color, count]) => {
                    updateSkillProgress(color, count);
                });
                
                setTimeout(() => {
                    dropPanels();
                    fillBoard();
                }, 500);
            }, 300);
        }

        // スキルプログレス更新
        function updateSkillProgress(color, count) {
            gameState.activeDeck.forEach((skill, index) => {
                if (skill.requiredColor === color || skill.requiredColor === 'any') {
                    if (!gameState.skillProgress[index]) {
                        gameState.skillProgress[index] = 0;
                    }
                    gameState.skillProgress[index] += count;
                    
                    if (gameState.skillProgress[index] >= skill.requiredCount) {
                        gameState.skillProgress[index] = skill.requiredCount;
                    }
                }
            });
            updateSkillButtons();
        }

        // スキルボタン更新
        function updateSkillButtons() {
            const container = document.getElementById('skillsContainer');
            container.innerHTML = '';
            
            gameState.activeDeck.forEach((skill, index) => {
                const button = document.createElement('button');
                button.className = 'skill-button';
                button.innerHTML = `
                    ${skill.name}<br>
                    <small>${gameState.skillProgress[index] || 0}/${skill.requiredCount}</small>
                    <div class="skill-progress" style="width: ${((gameState.skillProgress[index] || 0) / skill.requiredCount) * 100}%"></div>
                `;
                
                const canUse = (gameState.skillProgress[index] || 0) >= skill.requiredCount && 
                             !gameState.skillCooldowns[index] && gameState.isGameActive;
                button.disabled = !canUse;
                
                if (skill.iconUrl) {
                    button.style.backgroundImage = `url(${skill.iconUrl})`;
                    button.style.backgroundSize = 'cover';
                    button.style.color = 'white';
                    button.style.textShadow = '0 0 2px black';
                }
                
                button.onclick = () => useSkill(index);
                container.appendChild(button);
            });
        }

        // スキル使用
        function useSkill(skillIndex) {
            const skill = gameState.activeDeck[skillIndex];
            if (!skill) return;
            
            if (skill.cutsceneUrl) {
                showCutscene(skill.cutsceneUrl);
            }
            
            setTimeout(() => {
                executeSkillEffect(skill);
                
                gameState.skillProgress[skillIndex] = 0;
                gameState.skillCooldowns[skillIndex] = true;
                
                setTimeout(() => {
                    delete gameState.skillCooldowns[skillIndex];
                    updateSkillButtons();
                }, 1000);
                
                updateSkillButtons();
            }, skill.cutsceneUrl ? 1200 : 0);
        }

        // スキル効果実行
        function executeSkillEffect(skill) {
            const toRemove = [];
            
            if (skill.clearType === 'coordinates' && skill.clearCoordinates) {
                skill.clearCoordinates.forEach(({x, y}) => {
                    if (x >= 0 && x < 10 && y >= 0 && y < 10 && gameState.board[y][x]) {
                        toRemove.push({x, y});
                    }
                });
            } else if (skill.clearType === 'color' && skill.clearColorCount > 0) {
                let count = 0;
                for (let y = 0; y < 10 && count < skill.clearColorCount; y++) {
                    for (let x = 0; x < 10 && count < skill.clearColorCount; x++) {
                        if (gameState.board[y][x] && gameState.board[y][x].color === skill.clearColor) {
                            toRemove.push({x, y});
                            count++;
                        }
                    }
                }
            } else if (skill.clearType === 'random' && skill.randomClearCount > 0) {
                const allCells = [];
                for (let y = 0; y < 10; y++) {
                    for (let x = 0; x < 10; x++) {
                        if (gameState.board[y][x] && gameState.board[y][x].type !== 'empty') {
                            allCells.push({x, y});
                        }
                    }
                }
                
                for (let i = 0; i < Math.min(skill.randomClearCount, allCells.length); i++) {
                    const randomIndex = Math.floor(Math.random() * allCells.length);
                    toRemove.push(allCells.splice(randomIndex, 1)[0]);
                }
            }
            
            const removedColors = processRemovePanels(toRemove);
            
            setTimeout(() => {
                gameState.score += toRemove.length * 100;
                
                Object.entries(removedColors).forEach(([color, count]) => {
                    updateSkillProgress(color, count);
                });
                
                setTimeout(() => {
                    dropPanels();
                    
                    if (skill.specialPanel && skill.specialCoordinates) {
                        skill.specialCoordinates.forEach(({x, y}) => {
                            if (x >= 0 && x < 10 && y >= 0 && y < 10) {
                                if (skill.specialPanel === 'bomb') {
                                    gameState.board[y][x] = {
                                        type: 'bomb',
                                        color: 'orange'
                                    };
                                } else {
                                    const customPanel = gameState.specialPanels.find(p => p.name === skill.specialPanel);
                                    if (customPanel) {
                                        gameState.board[y][x] = {
                                            type: 'special',
                                            color: customPanel.color,
                                            emoji: customPanel.emoji,
                                            clearPattern: customPanel.clearCoordinates,
                                            imageUrl: customPanel.imageUrl
                                        };
                                    }
                                }
                            }
                        });
                    }
                    
                    fillBoard();
                }, 500);
                
                if (skill.specialEffect) {
                    applySpecialEffect(skill);
                }
            }, 300);
        }

        // 特殊効果適用
        function applySpecialEffect(skill) {
            if (skill.specialEffect === 'scoreBoost') {
                gameState.specialEffects.scoreBoost = {
                    multiplier: skill.effectValue,
                    duration: skill.effectDuration
                };
            } else if (skill.specialEffect === 'colorBoost') {
                gameState.specialEffects.colorBoost = {
                    color: skill.boostColor,
                    duration: skill.effectDuration
                };
            }
            updateEffectIndicator();
        }

        // 特殊効果更新
        function updateSpecialEffects() {
            Object.keys(gameState.specialEffects).forEach(effect => {
                if (gameState.specialEffects[effect].duration > 0) {
                    gameState.specialEffects[effect].duration--;
                    if (gameState.specialEffects[effect].duration <= 0) {
                        delete gameState.specialEffects[effect];
                    }
                }
            });
            updateEffectIndicator();
        }

        // カットシーン表示
        function showCutscene(imageUrl) {
            const cutscene = document.getElementById('cutscene');
            const image = document.getElementById('cutsceneImage');
            image.src = imageUrl;
            cutscene.style.display = 'flex';
            
            setTimeout(() => {
                cutscene.style.display = 'none';
            }, 1200);
        }

        // ゲーム開始
        function startGame() {
            gameState.isGameActive = true;
            gameState.score = 0;
            gameState.timeLeft = 60;
            gameState.chain = 0;
            gameState.skillProgress = {};
            gameState.skillCooldowns = {};
            gameState.specialEffects = {};
            
            document.getElementById('startButton').style.display = 'none';
            
            gameState.gameTimer = setInterval(() => {
                gameState.timeLeft--;
                updateDisplay();
                
                if (gameState.timeLeft <= 0) {
                    endGame();
                }
            }, 1000);
            
            fillBoard();
            updateSkillButtons();
        }

        // ゲーム終了
        function endGame() {
            gameState.isGameActive = false;
            clearInterval(gameState.gameTimer);
            
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('gameOverModal').style.display = 'flex';
        }

        // ゲームリセット
        function resetGame() {
            gameState.isGameActive = false;
            document.getElementById('gameOverModal').style.display = 'none';
            document.getElementById('startButton').style.display = 'block';
            
            if (gameState.gameTimer) {
                clearInterval(gameState.gameTimer);
            }
            
            gameState.score = 0;
            gameState.timeLeft = 60;
            gameState.chain = 0;
            gameState.skillProgress = {};
            gameState.skillCooldowns = {};
            gameState.specialEffects = {};
            
            fillBoard();
            updateSkillButtons();
            updateDisplay();
        }

        // モーダル操作
        function openModal() {
            document.getElementById('mainModal').style.display = 'block';
            updateSkillList();
            updatePanelList();
            updateDeckList();
            updateColorForm();
        }

        function closeModal() {
            document.getElementById('mainModal').style.display = 'none';
        }

        function showTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            document.querySelector(`[onclick="showTab('${tabName}')"]`).classList.add('active');
            document.getElementById(tabName + 'Tab').classList.add('active');
        }

        // 画像プレビュー
        function previewImage(input, previewId) {
            const preview = document.getElementById(previewId);
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    preview.src = e.target.result;
                    preview.style.display = 'block';
                };
                reader.readAsDataURL(input.files[0]);
            }
        }

        // スキル作成関連
        function toggleClearOptions() {
            const clearType = document.getElementById('clearType').value;
            document.getElementById('coordinatesSection').style.display = clearType === 'coordinates' ? 'block' : 'none';
            document.getElementById('colorClearSection').style.display = clearType === 'color' ? 'block' : 'none';
            document.getElementById('randomClearSection').style.display = clearType === 'random' ? 'block' : 'none';
        }

        function toggleEffectOptions() {
            const effect = document.getElementById('specialEffect').value;
            const options = document.getElementById('effectOptions');
            const colorOptions = document.getElementById('colorBoostOptions');
            
            options.style.display = effect ? 'block' : 'none';
            colorOptions.style.display = effect === 'colorBoost' ? 'block' : 'none';
        }

        function addClearCoordinate() {
            const container = document.getElementById('clearCoordinates');
            const div = document.createElement('div');
            div.className = 'coordinate-input';
            div.innerHTML = `
                <input type="number" placeholder="x" min="0" max="9">
                <input type="number" placeholder="y" min="0" max="9">
                <button type="button" class="remove-coordinate" onclick="removeCoordinate(this)">削除</button>
            `;
            container.appendChild(div);
        }

        function addSpecialCoordinate() {
            const container = document.getElementById('specialCoordinates');
            const div = document.createElement('div');
            div.className = 'coordinate-input';
            div.innerHTML = `
                <input type="number" placeholder="x" min="0" max="9">
                <input type="number" placeholder="y" min="0" max="9">
                <button type="button" class="remove-coordinate" onclick="removeCoordinate(this)">削除</button>
            `;
            container.appendChild(div);
        }

        function addPanelCoordinate() {
            const container = document.getElementById('panelClearCoordinates');
            const div = document.createElement('div');
            div.className = 'coordinate-input';
            div.innerHTML = `
                <input type="number" placeholder="x" min="-5" max="5">
                <input type="number" placeholder="y" min="-5" max="5">
                <button type="button" class="remove-coordinate" onclick="removeCoordinate(this)">削除</button>
            `;
            container.appendChild(div);
        }

        function removeCoordinate(button) {
            button.parentElement.remove();
        }

        // スキル作成
        function createSkill() {
            const name = document.getElementById('skillName').value;
            if (!name) {
                alert('スキル名を入力してください');
                return;
            }

            const skill = {
                name: name,
                requiredCount: parseInt(document.getElementById('requiredCount').value),
                requiredColor: document.getElementById('requiredColor').value,
                clearType: document.getElementById('clearType').value,
                specialPanel: document.getElementById('specialPanel').value,
                specialEffect: document.getElementById('specialEffect').value
            };

            const iconFile = document.getElementById('skillIcon').files[0];
            if (iconFile) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    skill.iconUrl = e.target.result;
                    continueSkillCreation(skill);
                };
                reader.readAsDataURL(iconFile);
            } else {
                continueSkillCreation(skill);
            }
        }

        function continueSkillCreation(skill) {
            const cutsceneFile = document.getElementById('skillCutscene').files[0];
            if (cutsceneFile) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    skill.cutsceneUrl = e.target.result;
                    finishSkillCreation(skill);
                };
                reader.readAsDataURL(cutsceneFile);
            } else {
                finishSkillCreation(skill);
            }
        }

        function finishSkillCreation(skill) {
            if (skill.clearType === 'coordinates') {
                skill.clearCoordinates = [];
                document.querySelectorAll('#clearCoordinates .coordinate-input').forEach(input => {
                    const x = parseInt(input.children[0].value);
                    const y = parseInt(input.children[1].value);
                    if (!isNaN(x) && !isNaN(y)) {
                        skill.clearCoordinates.push({x, y});
                    }
                });
            } else if (skill.clearType === 'color') {
                skill.clearColor = document.getElementById('clearColor').value;
                skill.clearColorCount = parseInt(document.getElementById('clearColorCount').value) || 0;
            } else if (skill.clearType === 'random') {
                skill.randomClearCount = parseInt(document.getElementById('randomClearCount').value) || 0;
            }

            skill.specialCoordinates = [];
            document.querySelectorAll('#specialCoordinates .coordinate-input').forEach(input => {
                const x = parseInt(input.children[0].value);
                const y = parseInt(input.children[1].value);
                if (!isNaN(x) && !isNaN(y)) {
                    skill.specialCoordinates.push({x, y});
                }
            });

            if (skill.specialEffect) {
                skill.effectDuration = parseInt(document.getElementById('effectDuration').value);
                skill.effectValue = parseFloat(document.getElementById('effectValue').value);
                if (skill.specialEffect === 'colorBoost') {
                    skill.boostColor = document.getElementById('boostColor').value;
                }
            }

            gameState.skills.push(skill);
            saveData();
            updateSkillList();
            updateDeckList();
            updateSpecialPanelOptions();
            
            document.getElementById('skillForm').reset();
            document.getElementById('skillIconPreview').style.display = 'none';
            document.getElementById('skillCutscenePreview').style.display = 'none';
            toggleClearOptions();
            toggleEffectOptions();
            
            alert('スキルを作成しました！');
        }

        // 特殊パネル作成
        function createPanel() {
            const name = document.getElementById('panelName').value;
            if (!name) {
                alert('パネル名を入力してください');
                return;
            }

            const panel = {
                name: name,
                color: document.getElementById('panelColor').value,
                clearCoordinates: []
            };

            document.querySelectorAll('#panelClearCoordinates .coordinate-input').forEach(input => {
                const x = parseInt(input.children[0].value);
                const y = parseInt(input.children[1].value);
                if (!isNaN(x) && !isNaN(y)) {
                    panel.clearCoordinates.push({x, y});
                }
            });

            const imageFile = document.getElementById('panelImage').files[0];
            if (imageFile) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    panel.imageUrl = e.target.result;
                    panel.emoji = '⭐';
                    gameState.specialPanels.push(panel);
                    saveData();
                    updatePanelList();
                    updateSpecialPanelOptions();
                    
                    document.getElementById('panelForm').reset();
                    document.getElementById('panelImagePreview').style.display = 'none';
                    
                    alert('特殊パネルを作成しました！');
                };
                reader.readAsDataURL(imageFile);
            } else {
                panel.emoji = '⭐';
                gameState.specialPanels.push(panel);
                saveData();
                updatePanelList();
                updateSpecialPanelOptions();
                
                document.getElementById('panelForm').reset();
                
                alert('特殊パネルを作成しました！');
            }
        }

        // 色画像保存
        function saveColorImages() {
            const colors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange'];
            let pending = colors.length;
            let completed = 0;

            colors.forEach(color => {
                const input = document.getElementById(`color${color.charAt(0).toUpperCase() + color.slice(1)}Image`);
                if (input.files && input.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        gameState.colorImages[color] = e.target.result;
                        completed++;
                        if (completed === pending) {
                            saveData();
                            updateDisplay();
                            alert('色画像を保存しました！');
                        }
                    };
                    reader.readAsDataURL(input.files[0]);
                } else {
                    completed++;
                    if (completed === pending) {
                        saveData();
                        updateDisplay();
                        alert('色画像を保存しました！');
                    }
                }
            });
        }

        // 色フォーム更新
        function updateColorForm() {
            const colors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange'];
            colors.forEach(color => {
                const preview = document.getElementById(`color${color.charAt(0).toUpperCase() + color.slice(1)}Preview`);
                if (gameState.colorImages[color]) {
                    preview.src = gameState.colorImages[color];
                    preview.style.display = 'block';
                } else {
                    preview.style.display = 'none';
                }
            });
        }

        // リスト更新
        function updateSkillList() {
            const list = document.getElementById('skillList');
            list.innerHTML = '';
            
            gameState.skills.forEach((skill, index) => {
                const div = document.createElement('div');
                div.className = 'skill-item';
                let effectText = skill.specialEffect ? 
                    (skill.specialEffect === 'scoreBoost' ? 
                        `スコア${skill.effectValue.toFixed(1)}倍(${skill.effectDuration}ターン)` :
                        `${skill.boostColor}出現率UP(${skill.effectDuration}ターン)`) : 'なし';
                div.innerHTML = `
                    <strong>${skill.name}</strong><br>
                    <small>必要: ${skill.requiredColor} ${skill.requiredCount}個</small><br>
                    <small>効果: ${skill.clearType}</small><br>
                    <small>特殊効果: ${effectText}</small>
                    <button class="button" onclick="deleteSkill(${index})" style="float: right; padding: 2px 8px;">削除</button>
                `;
                list.appendChild(div);
            });
        }

        function updatePanelList() {
            const list = document.getElementById('panelList');
            list.innerHTML = '';
            
            gameState.specialPanels.forEach((panel, index) => {
                const div = document.createElement('div');
                div.className = 'panel-item';
                div.innerHTML = `
                    <strong>${panel.name}</strong><br>
                    <small>色: ${panel.color}</small><br>
                    <small>消去範囲: ${panel.clearCoordinates.length}箇所</small>
                    <button class="button" onclick="deletePanel(${index})" style="float: right; padding: 2px 8px;">削除</button>
                `;
                list.appendChild(div);
            });
        }

        function updateDeckList() {
            const list = document.getElementById('deckSkillList');
            list.innerHTML = '';
            
            gameState.skills.forEach((skill, index) => {
                const div = document.createElement('div');
                div.className = 'skill-item';
                if (gameState.activeDeck.some(s => s.name === skill.name)) {
                    div.classList.add('selected');
                }
                let effectText = skill.specialEffect ? 
                    (skill.specialEffect === 'scoreBoost' ? 
                        `スコア${skill.effectValue.toFixed(1)}倍(${skill.effectDuration}ターン)` :
                        `${skill.boostColor}出現率UP(${skill.effectDuration}ターン)`) : 'なし';
                div.innerHTML = `
                    <strong>${skill.name}</strong><br>
                    <small>必要: ${skill.requiredColor} ${skill.requiredCount}個</small><br>
                    <small>効果: ${skill.clearType}</small><br>
                    <small>特殊効果: ${effectText}</small>
                `;
                div.onclick = () => toggleDeckSkill(skill, div);
                list.appendChild(div);
            });
        }

        function updateSpecialPanelOptions() {
            const select = document.getElementById('specialPanel');
            const customOptions = select.querySelectorAll('option[data-custom]');
            customOptions.forEach(option => option.remove());
            
            gameState.specialPanels.forEach(panel => {
                const option = document.createElement('option');
                option.value = panel.name;
                option.textContent = panel.name;
                option.dataset.custom = 'true';
                select.appendChild(option);
            });
        }

        // デッキ操作
        function toggleDeckSkill(skill, element) {
            const existingIndex = gameState.activeDeck.findIndex(s => s.name === skill.name);
            if (existingIndex !== -1) {
                gameState.activeDeck.splice(existingIndex, 1);
                element.classList.remove('selected');
            } else if (gameState.activeDeck.length < 4) {
                gameState.activeDeck.push(skill);
                element.classList.add('selected');
            } else {
                alert('デッキには最大4つのスキルまで設定できます');
            }
        }

        function saveDeck() {
            saveData();
            updateSkillButtons();
            alert('デッキを保存しました！');
        }

        // 削除
        function deleteSkill(index) {
            if (confirm('このスキルを削除しますか？')) {
                const skill = gameState.skills[index];
                gameState.skills.splice(index, 1);
                gameState.activeDeck = gameState.activeDeck.filter(s => s.name !== skill.name);
                saveData();
                updateSkillList();
                updateDeckList();
                updateSkillButtons();
            }
        }

        function deletePanel(index) {
            if (confirm('この特殊パネルを削除しますか？')) {
                gameState.specialPanels.splice(index, 1);
                saveData();
                updatePanelList();
                updateSpecialPanelOptions();
            }
        }

        // データ保存・読込
        function saveData() {
            const data = {
                skills: gameState.skills,
                specialPanels: gameState.specialPanels,
                activeDeck: gameState.activeDeck,
                colorImages: gameState.colorImages
            };
            localStorage.setItem('customTsumTsumData', JSON.stringify(data));
        }

        function loadData() {
            const savedData = localStorage.getItem('customTsumTsumData');
            if (savedData) {
                const data = JSON.parse(savedData);
                gameState.skills = data.skills || [];
                gameState.specialPanels = data.specialPanels || [];
                gameState.activeDeck = data.activeDeck || [];
                gameState.colorImages = data.colorImages || {
                    red: null,
                    blue: null,
                    green: null,
                    yellow: null,
                    purple: null,
                    orange: null
                };
            } else {
                gameState.skills = [
                    {
                        name: 'ランダム爆発',
                        requiredCount: 10,
                        requiredColor: 'red',
                        clearType: 'random',
                        randomClearCount: 5,
                        specialPanel: 'bomb',
                        specialCoordinates: [{x: 4, y: 4}, {x: 5, y: 5}],
                        specialEffect: '',
                        iconUrl: '',
                        cutsceneUrl: ''
                    },
                    {
                        name: 'ブルーライン',
                        requiredCount: 8,
                        requiredColor: 'blue',
                        clearType: 'coordinates',
                        clearCoordinates: [
                            {x: 0, y: 5}, {x: 1, y: 5}, {x: 2, y: 5}, 
                            {x: 3, y: 5}, {x: 4, y: 5}, {x: 5, y: 5},
                            {x: 6, y: 5}, {x: 7, y: 5}, {x: 8, y: 5}, {x: 9, y: 5}
                        ],
                        specialPanel: '',
                        specialCoordinates: [],
                        specialEffect: 'scoreBoost',
                        effectDuration: 3,
                        effectValue: 2.0,
                        iconUrl: '',
                        cutsceneUrl: ''
                    }
                ];
                gameState.activeDeck = gameState.skills.slice(0, 2);
                gameState.colorImages = {
                    red: null,
                    blue: null,
                    green: null,
                    yellow: null,
                    purple: null,
                    orange: null
                };
            }
        }

        // 特殊パネルのタップ処理
        function handleSpecialPanelTap(x, y) {
            const panel = gameState.board[y][x];
            if (panel.type === 'special' && panel.clearPattern) {
                const toRemove = [];
                panel.clearPattern.forEach(({x: dx, y: dy}) => {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < 10 && ny >= 0 && ny < 10) {
                        toRemove.push({x: nx, y: ny});
                    }
                });
                
                const removedColors = processRemovePanels(toRemove);
                
                setTimeout(() => {
                    gameState.score += toRemove.length * 80;
                    
                    Object.entries(removedColors).forEach(([color, count]) => {
                        updateSkillProgress(color, count);
                    });
                    
                    setTimeout(() => {
                        dropPanels();
                        fillBoard();
                    }, 500);
                }, 300);
            }
        }

        // ページ読み込み時の初期化
        window.addEventListener('DOMContentLoaded', function() {
            initGame();
        });

        // クリック外でモーダルを閉じる
        window.addEventListener('click', function(e) {
            const modal = document.getElementById('mainModal');
            if (e.target === modal) {
                closeModal();
            }
        });

        // モバイル対応のタッチイベント防止
        document.addEventListener('touchmove', function(e) {
            if (e.target.classList.contains('cell')) {
                e.preventDefault();
            }
        }, { passive: false });

        // ゲーム中のスワイプによる画面移動を防止
        document.addEventListener('touchstart', function(e) {
            if (gameState.isGameActive && e.target.classList.contains('cell')) {
                e.preventDefault();
            }
        }, { passive: false });

        // 初期データ読み込み
        initGame();
    </script>
</body>
</html>
