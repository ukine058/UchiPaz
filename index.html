<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CustomPuzzle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            user-select: none;
            overflow-x: hidden;
        }

        .container {
            max-width: 400px;
            margin: 0 auto;
            padding: 10px;
            position: relative;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 15px;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            color: white;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .skills-container {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            height: 50px;
        }

        .skill-button {
            flex: 1;
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 10px;
            padding: 5px;
            position: relative;
            overflow: hidden;
        }

        .skill-button:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .skill-button:not(:disabled):hover {
            transform: scale(1.05);
        }

        .skill-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: #00ff00;
            transition: width 0.3s;
        }

        .board {
            width: 100%;
            max-width: 350px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 10px;
            backdrop-filter: blur(10px);
            position: relative;
        }

        .effect-indicator {
            width: 100%;
            max-width: 350px;
            margin: 10px auto 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            text-align: center;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 2px;
            aspect-ratio: 1;
        }

        .cell {
            aspect-ratio: 1;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }

        .cell img {
            pointer-events: none;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .cell:hover {
            transform: scale(1.1);
        }

        .cell.selected {
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            transform: scale(1.1);
        }

        .cell.connected {
            animation: pulse 0.5s ease-in-out;
        }

        .cell.bomb {
            background: radial-gradient(circle, #ff9500, #ff6b00) !important;
            color: white;
            font-weight: bold;
        }

        .cell.special {
            border: 2px solid gold;
            animation: sparkle 1s infinite;
        }

        .cell.removing {
            animation: explode 0.5s ease-out forwards;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #fff;
            border-radius: 50%;
            pointer-events: none;
            animation: particle-burst 0.6s ease-out forwards;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        @keyframes sparkle {
            0%, 100% { box-shadow: 0 0 5px gold; }
            50% { box-shadow: 0 0 15px gold, 0 0 25px gold; }
        }

        @keyframes explode {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.5; }
            100% { transform: scale(0); opacity: 0; }
        }

        @keyframes particle-burst {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0) translate(var(--dx), var(--dy)); }
        }

        @keyframes slideInOut {
            0% { transform: translateX(100%); opacity: 0; }
            10% { transform: translateX(0); opacity: 1; }
            70% { transform: translateX(0); opacity: 1; }
            100% { transform: translateX(-100%); opacity: 0; }
        }

        .menu-button {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 20px;
            cursor: pointer;
            z-index: 1000;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            overflow-y: auto;
        }

        .modal-content {
            background: white;
            margin: 20px auto;
            padding: 20px;
            border-radius: 15px;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }

        .close {
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: #aaa;
        }

        .close:hover {
            color: #000;
        }

        .tab-container {
            display: flex;
            border-bottom: 2px solid #eee;
            margin-bottom: 20px;
        }

        .tab {
            flex: 1;
            padding: 10px;
            background: #f0f0f0;
            border: none;
            cursor: pointer;
            font-weight: bold;
        }

        .tab.active {
            background: #667eea;
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
        }

        .button:hover {
            background: #5a6fd8;
        }

        .skill-list,
        .panel-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
        }

        .skill-item,
        .panel-item {
            padding: 10px;
            margin-bottom: 10px;
            background: #f9f9f9;
            border-radius: 5px;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .skill-item:hover,
        .panel-item:hover {
            background: #e9e9e9;
        }

        .skill-item.selected,
        .panel-item.selected {
            border-color: #667eea;
            background: #e8f0fe;
        }

        .start-button {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1000;
        }

        .game-over-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 3000;
            align-items: center;
            justify-content: center;
        }

        .game-over-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 300px;
        }

        .color-red { background: #ff5274; }
        .color-blue { background: #3d9bff; }
        .color-green { background: #35e381; }
        .color-yellow { background: #f9ca24; }
        .color-purple { background: #be6cea; }
        .color-orange { background: #fd9644; }

        .cutscene {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 5000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .cutscene img {
            max-width: 80%;
            max-height: 80%;
            border-radius: 15px;
            animation: slideInOut 1.2s ease-out forwards;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
            background: #667eea;
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            margin-top: 5px;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .preview-image {
            max-width: 100px;
            max-height: 100px;
            margin-top: 10px;
            border-radius: 5px;
        }

        .grid-selector {
            display: grid;
            gap: 2px;
            margin-bottom: 10px;
            background: #f0f0f0;
            padding: 5px;
            border-radius: 5px;
        }

        .grid-selector-10x10 {
            grid-template-columns: repeat(10, 1fr);
            max-width: 300px;
        }

        .grid-selector-19x19 {
            grid-template-columns: repeat(19, 1fr);
            max-width: 400px;
        }

        .grid-cell {
            aspect-ratio: 1;
            border: 1px solid #ccc;
            background: #fff;
            cursor: pointer;
        }

        .grid-cell.selected {
            background: #667eea;
        }

        .grid-cell.center {
            background: #ff6b6b;
        }

        .emoji-input {
            font-size: 20px;
            text-align: center;
        }

        @media (max-width: 480px) {
            .container {
                padding: 5px;
            }
            
            .modal-content {
                margin: 10px;
                max-width: calc(100% - 20px);
            }
            
            .skill-button {
                font-size: 9px;
            }
            
            .grid-selector-19x19 {
                max-width: 300px;
            }
            
            .grid-cell {
                min-width: 15px;
                min-height: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎮 CustomPuzzle</h1>
        </div>
        
        <div class="game-info">
            <div>スコア: <span id="score">0</span></div>
            <div>時間: <span id="time">60</span>s</div>
            <div>チェーン: <span id="chain">0</span></div>
        </div>
        
        <div class="skills-container" id="skillsContainer"></div>
        
        <div class="board">
            <div class="grid" id="gameBoard"></div>
        </div>
        <div id="effectIndicator" class="effect-indicator" style="display:none;"></div>
    </div>

    <button class="menu-button" onclick="openModal()">⚙️</button>
    <button class="start-button" id="startButton" onclick="startGame()">ゲーム開始</button>

    <div id="mainModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>設定</h2>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            
            <div class="tab-container">
                <button class="tab active" onclick="showTab('skills')">スキル作成</button>
                <button class="tab" onclick="showTab('panels')">特殊パネル</button>
                <button class="tab" onclick="showTab('deck')">デッキ構築</button>
                <button class="tab" onclick="showTab('colors')">色設定</button>
            </div>
            
            <div id="skillsTab" class="tab-content active">
                <h3 id="skillFormTitle">スキル作成</h3>
                <form id="skillForm">
                    <div class="form-group">
                        <label>スキル名:</label>
                        <input type="text" id="skillName" placeholder="スキル名を入力">
                    </div>
                    
                    <div class="form-group">
                        <label>アイコン:</label>
                        <div class="file-input-wrapper">
                            <span>画像を選択</span>
                            <input type="file" id="skillIcon" accept="image/*" onchange="previewImage(this, 'skillIconPreview')">
                        </div>
                        <input type="text" id="skillEmoji" class="emoji-input" placeholder="絵文字を入力" maxlength="4">
                        <img id="skillIconPreview" class="preview-image" style="display:none;">
                    </div>
                    
                    <div class="form-group">
                        <label>カットイン画像:</label>
                        <div class="file-input-wrapper">
                            <span>ファイルを選択</span>
                            <input type="file" id="skillCutscene" accept="image/*" onchange="previewImage(this, 'skillCutscenePreview')">
                        </div>
                        <img id="skillCutscenePreview" class="preview-image" style="display:none;">
                    </div>
                    
                    <div class="form-group">
                        <label>必要消去数:</label>
                        <input type="number" id="requiredCount" min="1" value="10">
                    </div>
                    
                    <div class="form-group">
                        <label>必要な色:</label>
                        <select id="requiredColor">
                            <option value="red">赤</option>
                            <option value="blue">青</option>
                            <option value="green">緑</option>
                            <option value="yellow">黄</option>
                            <option value="purple">紫</option>
                            <option value="orange">オレンジ</option>
                            <option value="any">任意の色</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>消去方法:</label>
                        <select id="clearType" onchange="toggleClearOptions()">
                            <option value="none">なし</option>
                            <option value="coordinates">座標指定</option>
                            <option value="color">色消去</option>
                            <option value="random">ランダム消去</option>
                        </select>
                    </div>
                    
                    <div id="coordinatesSection" class="form-group" style="display:none;">
                        <label>消去座標 (10×10):</label>
                        <div id="clearGrid" class="grid-selector grid-selector-10x10"></div>
                    </div>
                    
                    <div id="colorClearSection" class="form-group" style="display:none;">
                        <label>消去する色:</label>
                        <select id="clearColor">
                            <option value="red">赤</option>
                            <option value="blue">青</option>
                            <option value="green">緑</option>
                            <option value="yellow">黄</option>
                            <option value="purple">紫</option>
                            <option value="orange">オレンジ</option>
                        </select>
                        <label>消去個数:</label>
                        <input type="number" id="clearColorCount" min="0" value="5">
                    </div>
                    
                    <div id="randomClearSection" class="form-group" style="display:none;">
                        <label>ランダム消去個数:</label>
                        <input type="number" id="randomClearCount" min="0" value="10">
                    </div>
                    
                    <div class="form-group">
                        <label>生成する特殊パネル:</label>
                        <select id="specialPanel">
                            <option value="">なし</option>
                            <option value="bomb">爆弾</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>特殊パネル生成座標 (10×10):</label>
                        <div id="specialGrid" class="grid-selector grid-selector-10x10"></div>
                    </div>
                    
                    <div class="form-group">
                        <label>特殊効果:</label>
                        <select id="specialEffect" onchange="toggleEffectOptions()">
                            <option value="">なし</option>
                            <option value="scoreBoost">スコア上昇</option>
                            <option value="colorBoost">特定色確率上昇</option>
                        </select>
                    </div>
                    
                    <div id="effectOptions" style="display:none;">
                        <div class="form-group">
                            <label>効果時間（手数）:</label>
                            <input type="number" id="effectDuration" min="1" value="5">
                        </div>
                        <div class="form-group">
                            <label>効果値:</label>
                            <input type="number" id="effectValue" min="0" step="0.1" value="2">
                        </div>
                        <div id="colorBoostOptions" class="form-group" style="display:none;">
                            <label>対象色:</label>
                            <select id="boostColor">
                                <option value="red">赤</option>
                                <option value="blue">青</option>
                                <option value="green">緑</option>
                                <option value="yellow">黄</option>
                                <option value="purple">紫</option>
                                <option value="orange">オレンジ</option>
                            </select>
                        </div>
                    </div>
                    
                    <button type="button" class="button" id="skillSubmitButton" onclick="createSkill()">スキル作成</button>
                </form>
                
                <div class="skill-list" id="skillList"></div>
            </div>
            
            <div id="panelsTab" class="tab-content">
                <h3 id="panelFormTitle">特殊パネル作成</h3>
                <form id="panelForm">
                    <div class="form-group">
                        <label>パネル名:</label>
                        <input type="text" id="panelName" placeholder="パネル名を入力">
                    </div>
                    
                    <div class="form-group">
                        <label>パネルアイコン:</label>
                        <div class="file-input-wrapper">
                            <span>画像を選択</span>
                            <input type="file" id="panelImage" accept="image/*" onchange="previewImage(this, 'panelImagePreview')">
                        </div>
                        <input type="text" id="panelEmoji" class="emoji-input" placeholder="絵文字を入力" maxlength="4">
                        <img id="panelImagePreview" class="preview-image" style="display:none;">
                    </div>
                    
                    <div class="form-group">
                        <label>基本色:</label>
                        <select id="panelColor">
                            <option value="red">赤</option>
                            <option value="blue">青</option>
                            <option value="green">緑</option>
                            <option value="yellow">黄</option>
                            <option value="purple">紫</option>
                            <option value="orange">オレンジ</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>消去範囲 (19×19, 相対座標):</label>
                        <div id="panelClearGrid" class="grid-selector grid-selector-19x19"></div>
                        <small>中心が(0,0)の相対座標</small>
                    </div>
                    
                    <button type="button" class="button" id="panelSubmitButton" onclick="createPanel()">パネル作成</button>
                </form>
                
                <div class="panel-list" id="panelList"></div>
            </div>
            
            <div id="deckTab" class="tab-content">
                <h3>デッキ構築</h3>
                <p>使用するスキルを選択してください（最大4個）</p>
                <div class="skill-list" id="deckSkillList"></div>
                <button type="button" class="button" onclick="saveDeck()">デッキ保存</button>
            </div>
            
            <div id="colorsTab" class="tab-content">
    <h3>色ごとの設定</h3>
    <form id="colorForm">
        <div class="form-group">
            <label>赤:</label>
            <div class="file-input-wrapper">
                <span>画像を選択</span>
                <input type="file" id="colorRedImage" accept="image/*" onchange="previewImage(this, 'colorRedPreview')">
            </div>
            <input type="text" id="colorRedEmoji" class="emoji-input" placeholder="絵文字を入力" maxlength="4">
            <img id="colorRedPreview" class="preview-image" style="display:none;">
            <button type="button" class="button" onclick="clearColorImage('red')" style="background: #ff6b6b; margin-top: 5px;">画像解除</button>
        </div>
        <div class="form-group">
            <label>青:</label>
            <div class="file-input-wrapper">
                <span>画像を選択</span>
                <input type="file" id="colorBlueImage" accept="image/*" onchange="previewImage(this, 'colorBluePreview')">
            </div>
            <input type="text" id="colorBlueEmoji" class="emoji-input" placeholder="絵文字を入力" maxlength="4">
            <img id="colorBluePreview" class="preview-image" style="display:none;">
            <button type="button" class="button" onclick="clearColorImage('blue')" style="background: #ff6b6b; margin-top: 5px;">画像解除</button>
        </div>
        <div class="form-group">
            <label>緑:</label>
            <div class="file-input-wrapper">
                <span>画像を選択</span>
                <input type="file" id="colorGreenImage" accept="image/*" onchange="previewImage(this, 'colorGreenPreview')">
            </div>
            <input type="text" id="colorGreenEmoji" class="emoji-input" placeholder="絵文字を入力" maxlength="4">
            <img id="colorGreenPreview" class="preview-image" style="display:none;">
            <button type="button" class="button" onclick="clearColorImage('green')" style="background: #ff6b6b; margin-top: 5px;">画像解除</button>
        </div>
        <div class="form-group">
            <label>黄:</label>
            <div class="file-input-wrapper">
                <span>画像を選択</span>
                <input type="file" id="colorYellowImage" accept="image/*" onchange="previewImage(this, 'colorYellowPreview')">
            </div>
            <input type="text" id="colorYellowEmoji" class="emoji-input" placeholder="絵文字を入力" maxlength="4">
            <img id="colorYellowPreview" class="preview-image" style="display:none;">
            <button type="button" class="button" onclick="clearColorImage('yellow')" style="background: #ff6b6b; margin-top: 5px;">画像解除</button>
        </div>
        <div class="form-group">
            <label>紫:</label>
            <div class="file-input-wrapper">
                <span>画像を選択</span>
                <input type="file" id="colorPurpleImage" accept="image/*" onchange="previewImage(this, 'colorPurplePreview')">
            </div>
            <input type="text" id="colorPurpleEmoji" class="emoji-input" placeholder="絵文字を入力" maxlength="4">
            <img id="colorPurplePreview" class="preview-image" style="display:none;">
            <button type="button" class="button" onclick="clearColorImage('purple')" style="background: #ff6b6b; margin-top: 5px;">画像解除</button>
        </div>
        <div class="form-group">
            <label>オレンジ:</label>
            <div class="file-input-wrapper">
                <span>画像を選択</span>
                <input type="file" id="colorOrangeImage" accept="image/*" onchange="previewImage(this, 'colorOrangePreview')">
            </div>
            <input type="text" id="colorOrangeEmoji" class="emoji-input" placeholder="絵文字を入力" maxlength="4">
            <img id="colorOrangePreview" class="preview-image" style="display:none;">
            <button type="button" class="button" onclick="clearColorImage('orange')" style="background: #ff6b6b; margin-top: 5px;">画像解除</button>
        </div>
        <button type="button" class="button" onclick="saveColorSettings()">保存</button>
    </form>
</div>
        </div>
    </div>

    <div id="gameOverModal" class="game-over-modal">
        <div class="game-over-content">
            <h2>ゲーム終了！</h2>
            <p>最終スコア: <span id="finalScore">0</span></p>
            <button class="button" onclick="resetGame()">もう一度</button>
        </div>
    </div>

    <div id="cutscene" class="cutscene">
        <img id="cutsceneImage" src="" alt="スキル発動">
    </div>

    <script>
        // gameStateに新しいフラグを追加
        let gameState = {
            board: [],
            score: 0,
            timeLeft: 60,
            chain: 0,
            selectedCells: [],
            isGameActive: false,
            skills: [],
            specialPanels: [],
            activeDeck: [],
            skillCooldowns: {},
            skillProgress: {},
            specialEffects: {},
            gameTimer: null,
            colorImages: {
                red: null,
                blue: null,
                green: null,
                yellow: null,
                purple: null,
                orange: null
            },
            colorEmojis: {
                red: null,
                blue: null,
                green: null,
                yellow: null,
                purple: null,
                orange: null
            },
            colorWeights: {
                red: 1,
                blue: 1,
                green: 1,
                yellow: 1,
                purple: 1,
                orange: 1
            },
            isTimerRunning: true,
            pendingActions: [],
            isProcessingAction: false, // アクション処理中のフラグ
            isBombProcessing: false,  // 爆弾処理中のフラグ
            isSkillProcessing: false // スキル処理中のフラグ
        };

        const colors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange'];
        const colorEmojis = {
            red: '🔴',
            blue: '🔵',
            green: '🟢',
            yellow: '🟡',
            purple: '🟣',
            orange: '🟠'
        };

        function initGame() {
            createBoard();
            loadData();
            updateSkillButtons();
            updateSpecialPanelOptions();
            fillBoard();
            updateEffectIndicator();
            initSkillForm();
            initPanelForm();
        }

        function createBoard() {
            const board = document.getElementById('gameBoard');
            board.innerHTML = '';
            gameState.board = [];
            
            for (let y = 0; y < 10; y++) {
                gameState.board[y] = [];
                for (let x = 0; x < 10; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.addEventListener('mousedown', startSelection);
                    cell.addEventListener('mouseenter', continueSelection);
                    cell.addEventListener('mouseup', endSelection);
                    cell.addEventListener('touchstart', handleTouch);
                    cell.addEventListener('touchmove', handleTouchMove);
                    cell.addEventListener('touchend', handleTouchEnd);
                    board.appendChild(cell);
                    gameState.board[y][x] = null;
                }
            }
        }

        function weightedRandomColor() {
            const weights = colors.map(color => gameState.colorWeights[color]);
            const totalWeight = weights.reduce((sum, w) => sum + w, 0);
            const random = Math.random() * totalWeight;
            let sum = 0;
            
            for (let i = 0; i < colors.length; i++) {
                sum += weights[i];
                if (random <= sum) {
                    return colors[i];
                }
            }
            return colors[colors.length - 1];
        }

        function fillBoard() {
            for (let y = 0; y < 10; y++) {
                for (let x = 0; x < 10; x++) {
                    if (!gameState.board[y][x] || gameState.board[y][x].type === 'empty') {
                        const color = weightedRandomColor();
                        gameState.board[y][x] = {
                            type: 'normal',
                            color: color
                        };
                    }
                }
            }
            updateDisplay();
        }

        function updateDisplay() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                const panel = gameState.board[y][x];
                
                cell.innerHTML = '';
                cell.className = 'cell';
                if (panel && panel.type !== 'empty') {
                    cell.classList.add(`color-${panel.color}`);
                    if (panel.type === 'bomb') {
                        cell.classList.add('bomb');
                        cell.textContent = '💣';
                    } else if (panel.type === 'special') {
                        cell.classList.add('special');
                        if (panel.imageUrl) {
                            const img = document.createElement('img');
                            img.src = panel.imageUrl;
                            cell.appendChild(img);
                        } else if (panel.emoji) {
                            cell.textContent = panel.emoji;
                        } else {
                            cell.textContent = '⭐';
                        }
                    } else if (gameState.colorImages[panel.color]) {
                        const img = document.createElement('img');
                        img.src = gameState.colorImages[panel.color];
                        cell.appendChild(img);
                    } else if (gameState.colorEmojis[panel.color]) {
                        cell.textContent = gameState.colorEmojis[panel.color];
                    } else {
                        cell.textContent = colorEmojis[panel.color];
                    }
                }
            });
            
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('time').textContent = gameState.timeLeft;
            document.getElementById('chain').textContent = gameState.chain;
            updateEffectIndicator();
        }

        function updateEffectIndicator() {
            const indicator = document.getElementById('effectIndicator');
            const effects = [];
            
            if (gameState.specialEffects.scoreBoost) {
                effects.push(`スコア${gameState.specialEffects.scoreBoost.multiplier}倍 (${gameState.specialEffects.scoreBoost.duration}ターン)`);
            }
            if (gameState.specialEffects.colorBoost) {
                gameState.specialEffects.colorBoost.forEach(boost => {
                    effects.push(`${boost.color}出現率${boost.multiplier.toFixed(1)}倍 (${boost.duration}ターン)`);
                });
            }
            
            if (effects.length > 0) {
                indicator.textContent = effects.join(', ');
                indicator.style.display = 'block';
            } else {
                indicator.style.display = 'none';
            }
        }

        let isSelecting = false;
        let lastSelectedCell = null;

        function startSelection(e) {
            if (!gameState.isGameActive || gameState.isProcessingAction) return;
            
            isSelecting = true;
            gameState.selectedCells = [];
            const cell = e.target.closest('.cell');
            if (!cell) return;
            
            const x = parseInt(cell.dataset.x);
            const y = parseInt(cell.dataset.y);
            
            if (gameState.board[y][x] && gameState.board[y][x].type === 'bomb') {
                if (gameState.isBombProcessing) return; // 爆弾処理中は無視
                queueAction(() => explodeBomb(x, y));
                return;
            }
            
            if (gameState.board[y][x] && gameState.board[y][x].type === 'special') {
                queueAction(() => handleSpecialPanelTap(x, y));
                return;
            }
            
            selectCell(x, y);
            lastSelectedCell = {x, y};
        }

        function continueSelection(e) {
            if (!isSelecting || !gameState.isGameActive) return;
            
            const cell = e.target.closest('.cell');
            if (!cell) return;
            
            const x = parseInt(cell.dataset.x);
            const y = parseInt(cell.dataset.y);
            
            if (lastSelectedCell && isAdjacent(lastSelectedCell.x, lastSelectedCell.y, x, y)) {
                const panel = gameState.board[y][x];
                if (panel && panel.type === 'normal' && 
                    (gameState.selectedCells.length === 0 || 
                     gameState.selectedCells[0].color === panel.color)) {
                    selectCell(x, y);
                    lastSelectedCell = {x, y};
                }
            }
        }

        function endSelection() {
            if (!isSelecting || !gameState.isGameActive) return;
            
            isSelecting = false;
            if (gameState.selectedCells.length >= 3) {
                queueAction(processChain);
            } else {
                clearSelection();
            }
        }

        function handleTouch(e) {
            e.preventDefault();
            startSelection({target: e.target.closest('.cell')});
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const element = document.elementFromPoint(touch.clientX, touch.clientY);
            if (element) {
                continueSelection({target: element.closest('.cell')});
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            endSelection();
        }

        function selectCell(x, y) {
            const panel = gameState.board[y][x];
            if (!panel || panel.type !== 'normal') return;
            
            if (gameState.selectedCells.some(cell => cell.x === x && cell.y === y)) return;
            
            if (gameState.selectedCells.length === 0 || 
                gameState.selectedCells[0].color === panel.color) {
                gameState.selectedCells.push({x, y, color: panel.color});
                const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                cell.classList.add('selected');
            }
        }

        function isAdjacent(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) <= 1 && Math.abs(y1 - y2) <= 1 && !(x1 === x2 && y1 === y2);
        }

        function clearSelection() {
            gameState.selectedCells = [];
            document.querySelectorAll('.cell.selected').forEach(cell => {
                cell.classList.remove('selected');
            });
        }

        // queueActionの修正：アクション追加を制限
        function queueAction(action) {
            if (gameState.isProcessingAction) {
                return; // 処理中は新たなアクションを無視
            }
            gameState.pendingActions.push(action);
            if (gameState.pendingActions.length === 1) {
                processNextAction();
            }
        }

        // processNextActionの修正：フラグを管理
        function processNextAction() {
            if (gameState.pendingActions.length === 0) {
                gameState.isProcessingAction = false;
                if (gameState.timeLeft <= 0 && gameState.isGameActive) {
                    endGame();
                }
                return;
            }

            gameState.isProcessingAction = true;
            const action = gameState.pendingActions[0];
            action();
        }

        // processChainの修正：フラグ管理（変更は最小限）
        function processChain() {
            const chainLength = gameState.selectedCells.length;
            gameState.chain = chainLength;
            
            const removedColors = processRemovePanels(gameState.selectedCells);
            
            setTimeout(() => {
                const baseScore = chainLength * 95;
                const bonusScore = Math.pow(chainLength, 1.2) * 5;
                const multiplier = gameState.specialEffects.scoreBoost ? gameState.specialEffects.scoreBoost.multiplier : 1;
                gameState.score += Math.floor((baseScore + bonusScore) * multiplier);
                
                Object.entries(removedColors).forEach(([color, count]) => {
                    updateSkillProgress(color, count);
                });
                
                if (chainLength >= 6) {
                    const centerCell = gameState.selectedCells[Math.floor(chainLength / 2)];
                    setTimeout(() => {
                        gameState.board[centerCell.y][centerCell.x] = {
                            type: 'bomb',
                            color: 'orange'
                        };
                        updateDisplay();
                    }, 300);
                }
                
                updateSpecialEffects();
                
                setTimeout(() => {
                    dropPanels();
                    fillBoard();
                    clearSelection();
                    gameState.pendingActions.shift();
                    processNextAction();
                }, 500);
            }, 300);
        }

        function processRemovePanels(panels) {
            const removedColors = {};
            const toProcess = [...panels];
            const processed = new Set();
            
            while (toProcess.length > 0) {
                const {x, y} = toProcess.shift();
                if (processed.has(`${x},${y}`)) continue;
                processed.add(`${x},${y}`);
                
                const panel = gameState.board[y][x];
                if (!panel || panel.type === 'empty') continue;
                
                createParticles(x, y);
                const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                cell.classList.add('removing');
                
                if (panel.type === 'special' && panel.clearPattern) {
                    panel.clearPattern.forEach(({x: dx, y: dy}) => {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < 10 && ny >= 0 && ny < 10 && !processed.has(`${nx},${ny}`)) {
                            toProcess.push({x: nx, y: ny});
                        }
                    });
                } else if (panel.type === 'bomb') {
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < 10 && ny >= 0 && ny < 10 && !processed.has(`${nx},${ny}`)) {
                                toProcess.push({x: nx, y: ny});
                            }
                        }
                    }
                }
                
                if (panel.color) {
                    removedColors[panel.color] = (removedColors[panel.color] || 0) + 1;
                }
                
                gameState.board[y][x] = {type: 'empty'};
            }
            
            return removedColors;
        }

        function createParticles(x, y) {
            const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
            const rect = cell.getBoundingClientRect();
            
            for (let i = 0; i < 5; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = rect.left + rect.width / 2 + 'px';
                particle.style.top = rect.top + rect.height / 2 + 'px';
                particle.style.setProperty('--dx', `${(Math.random() - 0.5) * 100}px`);
                particle.style.setProperty('--dy', `${(Math.random() - 0.5) * 100}px`);
                document.body.appendChild(particle);
                
                setTimeout(() => particle.remove(), 600);
            }
        }

        function dropPanels() {
            for (let x = 0; x < 10; x++) {
                let writeIndex = 9;
                for (let y = 9; y >= 0; y--) {
                    if (gameState.board[y][x] && gameState.board[y][x].type !== 'empty') {
                        if (y !== writeIndex) {
                            gameState.board[writeIndex][x] = gameState.board[y][x];
                            gameState.board[y][x] = {type: 'empty'};
                        }
                        writeIndex--;
                    }
                }
            }
        }

        // explodeBombの修正：フラグ管理と連打防止
        function explodeBomb(x, y) {
            if (gameState.isBombProcessing) {
                gameState.pendingActions.shift();
                processNextAction();
                return;
            }
            
            gameState.isBombProcessing = true;
            const toRemove = [];
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < 10 && ny >= 0 && ny < 10) {
                        toRemove.push({x: nx, y: ny});
                    }
                }
            }
            
            const removedColors = processRemovePanels(toRemove);
            
            setTimeout(() => {
                const baseScore = toRemove.length * 95;
                const bonusScore = Math.pow(toRemove.length, 1.2) * 5;
                const multiplier = gameState.specialEffects.scoreBoost ? gameState.specialEffects.scoreBoost.multiplier : 1;
                gameState.score += Math.floor((baseScore + bonusScore) * multiplier);
                
                Object.entries(removedColors).forEach(([color, count]) => {
                    updateSkillProgress(color, count);
                });
                
                updateSpecialEffects();
                
                setTimeout(() => {
                    dropPanels();
                    fillBoard();
                    gameState.isBombProcessing = false;
                    gameState.pendingActions.shift();
                    processNextAction();
                }, 500);
            }, 300);
        }

        function updateSkillProgress(color, count) {
            gameState.activeDeck.forEach((skill, index) => {
                if (skill.requiredColor === color || skill.requiredColor === 'any') {
                    if (!gameState.skillProgress[index]) {
                        gameState.skillProgress[index] = 0;
                    }
                    gameState.skillProgress[index] += count;
                    
                    if (gameState.skillProgress[index] >= skill.requiredCount) {
                        gameState.skillProgress[index] = skill.requiredCount;
                    }
                }
            });
            updateSkillButtons();
        }

        function updateSkillButtons() {
            const container = document.getElementById('skillsContainer');
            container.innerHTML = '';
            
            gameState.activeDeck.forEach((skill, index) => {
                const button = document.createElement('button');
                button.className = 'skill-button';
                button.innerHTML = `
                    ${skill.name}<br>
                    <small>${gameState.skillProgress[index] || 0}/${skill.requiredCount}</small>
                    <div class="skill-progress" style="width: ${((gameState.skillProgress[index] || 0) / skill.requiredCount) * 100}%"></div>
                `;
                
                const canUse = (gameState.skillProgress[index] || 0) >= skill.requiredCount && 
                             !gameState.skillCooldowns[index] && gameState.isGameActive;
                button.disabled = !canUse;
                
                if (skill.iconUrl) {
                    button.style.backgroundImage = `url(${skill.iconUrl})`;
                    button.style.backgroundSize = 'cover';
                    button.style.color = 'white';
                    button.style.textShadow = '0 0 2px black';
                } else if (skill.emoji) {
                    button.textContent = skill.emoji + ' ' + button.textContent;
                }
                
                button.onclick = () => queueAction(() => useSkill(index));
                container.appendChild(button);
            });
        }

        // useSkillの修正：スキル連打防止
        function useSkill(skillIndex) {
            if (gameState.isSkillProcessing || gameState.skillCooldowns[skillIndex]) {
                gameState.pendingActions.shift();
                processNextAction();
                return;
            }
            
            const skill = gameState.activeDeck[skillIndex];
            if (!skill) {
                gameState.pendingActions.shift();
                processNextAction();
                return;
            }
            
            gameState.isSkillProcessing = true;
            
            if (skill.cutsceneUrl) {
                showCutscene(skill.cutsceneUrl);
            }
            
            setTimeout(() => {
                executeSkillEffect(skill);
                
                gameState.skillProgress[skillIndex] = 0;
                gameState.skillCooldowns[skillIndex] = true;
                
                setTimeout(() => {
                    delete gameState.skillCooldowns[skillIndex];
                    updateSkillButtons();
                    gameState.isSkillProcessing = false;
                    gameState.pendingActions.shift();
                    processNextAction();
                }, 1000);
                
                updateSkillButtons();
            }, skill.cutsceneUrl ? 1200 : 0);
        }

        function executeSkillEffect(skill) {
            const toRemove = [];
            
            if (skill.clearType === 'coordinates' && skill.clearCoordinates) {
                skill.clearCoordinates.forEach(({x, y}) => {
                    if (x >= 0 && x < 10 && y >= 0 && y < 10 && gameState.board[y][x]) {
                        toRemove.push({x, y});
                    }
                });
            } else if (skill.clearType === 'color' && skill.clearColorCount > 0) {
                let count = 0;
                for (let y = 0; y < 10 && count < skill.clearColorCount; y++) {
                    for (let x = 0; x < 10 && count < skill.clearColorCount; x++) {
                        if (gameState.board[y][x] && gameState.board[y][x].color === skill.clearColor) {
                            toRemove.push({x, y});
                            count++;
                        }
                    }
                }
            } else if (skill.clearType === 'random' && skill.randomClearCount > 0) {
                const allCells = [];
                for (let y = 0; y < 10; y++) {
                    for (let x = 0; x < 10; x++) {
                        if (gameState.board[y][x] && gameState.board[y][x].type !== 'empty') {
                            allCells.push({x, y});
                        }
                    }
                }
                
                for (let i = 0; i < Math.min(skill.randomClearCount, allCells.length); i++) {
                    const randomIndex = Math.floor(Math.random() * allCells.length);
                    toRemove.push(allCells.splice(randomIndex, 1)[0]);
                }
            }
            
            const removedColors = processRemovePanels(toRemove);
            
            setTimeout(() => {
                const baseScore = toRemove.length * 95;
                const bonusScore = Math.pow(toRemove.length, 1.2) * 5;
                const multiplier = gameState.specialEffects.scoreBoost ? gameState.specialEffects.scoreBoost.multiplier : 1;
                gameState.score += Math.floor((baseScore + bonusScore) * multiplier);
                
                Object.entries(removedColors).forEach(([color, count]) => {
                    updateSkillProgress(color, count);
                });
                
                setTimeout(() => {
                    dropPanels();
                    
                    if (skill.specialPanel && skill.specialCoordinates) {
                        skill.specialCoordinates.forEach(({x, y}) => {
                            if (x >= 0 && x < 10 && y >= 0 && y < 10) {
                                if (skill.specialPanel === 'bomb') {
                                    gameState.board[y][x] = {
                                        type: 'bomb',
                                        color: 'orange'
                                    };
                                } else {
                                    const customPanel = gameState.specialPanels.find(p => p.name === skill.specialPanel);
                                    if (customPanel) {
                                        gameState.board[y][x] = {
                                            type: 'special',
                                            color: customPanel.color,
                                            emoji: customPanel.emoji,
                                            clearPattern: customPanel.clearCoordinates,
                                            imageUrl: customPanel.imageUrl
                                        };
                                    }
                                }
                            }
                        });
                    }
                    
                    fillBoard();
                    gameState.pendingActions.shift();
                    processNextAction();
                }, 500);
                
                if (skill.specialEffect) {
                    applySpecialEffect(skill);
                }
            }, 300);
        }

        function applySpecialEffect(skill) {
            if (skill.specialEffect === 'scoreBoost') {
                gameState.specialEffects.scoreBoost = {
                    multiplier: skill.effectValue,
                    duration: skill.effectDuration
                };
            } else if (skill.specialEffect === 'colorBoost') {
                if (!gameState.specialEffects.colorBoost) {
                    gameState.specialEffects.colorBoost = [];
                }
                gameState.specialEffects.colorBoost.push({
                    color: skill.boostColor,
                    multiplier: skill.effectValue,
                    duration: skill.effectDuration
                });
                updateColorWeights();
            }
            updateEffectIndicator();
        }

        function updateColorWeights() {
            colors.forEach(color => {
                gameState.colorWeights[color] = 1;
            });
            
            if (gameState.specialEffects.colorBoost) {
                gameState.specialEffects.colorBoost.forEach(boost => {
                    if (boost.duration > 0) {
                        gameState.colorWeights[boost.color] *= boost.multiplier;
                    }
                });
            }
        }

        function updateSpecialEffects() {
            Object.keys(gameState.specialEffects).forEach(effect => {
                if (effect === 'colorBoost') {
                    gameState.specialEffects.colorBoost = gameState.specialEffects.colorBoost.filter(boost => {
                        boost.duration--;
                        return boost.duration > 0;
                    });
                    if (gameState.specialEffects.colorBoost.length === 0) {
                        delete gameState.specialEffects.colorBoost;
                    }
                    updateColorWeights();
                } else if (gameState.specialEffects[effect].duration > 0) {
                    gameState.specialEffects[effect].duration--;
                    if (gameState.specialEffects[effect].duration <= 0) {
                        delete gameState.specialEffects[effect];
                    }
                }
            });
            updateEffectIndicator();
        }

        function showCutscene(imageUrl) {
            const cutscene = document.getElementById('cutscene');
            const image = document.getElementById('cutsceneImage');
            image.src = imageUrl;
            cutscene.style.display = 'flex';
            
            if (gameState.isTimerRunning) {
                clearInterval(gameState.gameTimer);
                gameState.isTimerRunning = false;
            }
            
            setTimeout(() => {
                cutscene.style.display = 'none';
                if (!gameState.isTimerRunning && gameState.isGameActive) {
                    gameState.gameTimer = setInterval(updateTimer, 1000);
                    gameState.isTimerRunning = true;
                }
            }, 1200);
        }

        function updateTimer() {
            gameState.timeLeft--;
            updateDisplay();
            
            if (gameState.timeLeft <= 0 && gameState.pendingActions.length === 0) {
                endGame();
            }
        }

        function startGame() {
            gameState.isGameActive = true;
            gameState.score = 0;
            gameState.timeLeft = 60;
            gameState.chain = 0;
            gameState.skillProgress = {};
            gameState.skillCooldowns = {};
            gameState.specialEffects = {};
            gameState.pendingActions = [];
            gameState.colorWeights = {
                red: 1,
                blue: 1,
                green: 1,
                yellow: 1,
                purple: 1,
                orange: 1
            };
            
            document.getElementById('startButton').style.display = 'none';
            
            gameState.gameTimer = setInterval(updateTimer, 1000);
            gameState.isTimerRunning = true;
            
            fillBoard();
            updateSkillButtons();
        }

        function endGame() {
            gameState.isGameActive = false;
            clearInterval(gameState.gameTimer);
            gameState.isTimerRunning = false;
            
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('gameOverModal').style.display = 'flex';
        }

        function resetGame() {
            gameState.isGameActive = false;
            document.getElementById('gameOverModal').style.display = 'none';
            document.getElementById('startButton').style.display = 'block';
            
            if (gameState.gameTimer) {
                clearInterval(gameState.gameTimer);
            }
            
            gameState.score = 0;
            gameState.timeLeft = 60;
            gameState.chain = 0;
            gameState.skillProgress = {};
            gameState.skillCooldowns = {};
            gameState.specialEffects = {};
            gameState.pendingActions = [];
            gameState.colorWeights = {
                red: 1,
                blue: 1,
                green: 1,
                yellow: 1,
                purple: 1,
                orange: 1
            };
            
            fillBoard();
            updateSkillButtons();
            updateDisplay();
        }

        function openModal() {
            document.getElementById('mainModal').style.display = 'block';
            updateSkillList();
            updatePanelList();
            updateDeckList();
            updateColorForm();
        }

        function closeModal() {
            document.getElementById('mainModal').style.display = 'none';
            resetSkillForm();
            resetPanelForm();
        }

        function showTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            document.querySelector(`[onclick="showTab('${tabName}')"]`).classList.add('active');
            document.getElementById(tabName + 'Tab').classList.add('active');
        }

        function previewImage(input, previewId) {
            const preview = document.getElementById(previewId);
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    preview.src = e.target.result;
                    preview.style.display = 'block';
                };
                reader.readAsDataURL(input.files[0]);
            }
        }

        function initGridSelector(containerId, size, isRelative = false) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.x = isRelative ? x - Math.floor(size / 2) : x;
                    cell.dataset.y = isRelative ? y - Math.floor(size / 2) : y;
                    if (isRelative && x === Math.floor(size / 2) && y === Math.floor(size / 2)) {
                        cell.classList.add('center');
                    }
                    cell.onclick = () => toggleGridCell(cell, containerId);
                    container.appendChild(cell);
                }
            }
        }

        function toggleGridCell(cell, containerId) {
            cell.classList.toggle('selected');
        }

        function getSelectedCoordinates(containerId, isRelative = false) {
            const coordinates = [];
            document.querySelectorAll(`#${containerId} .grid-cell.selected`).forEach(cell => {
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                if (!isNaN(x) && !isNaN(y)) {
                    coordinates.push({x, y});
                }
            });
            return coordinates;
        }

        function setSelectedCoordinates(containerId, coordinates, isRelative = false) {
            document.querySelectorAll(`#${containerId} .grid-cell`).forEach(cell => {
                cell.classList.remove('selected');
            });
            coordinates.forEach(({x, y}) => {
                const adjustedX = isRelative ? x + Math.floor((containerId === 'panelClearGrid' ? 19 : 10) / 2) : x;
                const adjustedY = isRelative ? y + Math.floor((containerId === 'panelClearGrid' ? 19 : 10) / 2) : y;
                const cell = document.querySelector(`#${containerId} [data-x="${adjustedX}"][data-y="${adjustedY}"]`);
                if (cell) cell.classList.add('selected');
            });
        }

        function initSkillForm() {
            initGridSelector('clearGrid', 10);
            initGridSelector('specialGrid', 10);
            toggleClearOptions();
        }

        function initPanelForm() {
            initGridSelector('panelClearGrid', 19, true);
        }

        function toggleClearOptions() {
            const clearType = document.getElementById('clearType').value;
            document.getElementById('coordinatesSection').style.display = clearType === 'coordinates' ? 'block' : 'none';
            document.getElementById('colorClearSection').style.display = clearType === 'color' ? 'block' : 'none';
            document.getElementById('randomClearSection').style.display = clearType === 'random' ? 'block' : 'none';
        }

        function toggleEffectOptions() {
            const effect = document.getElementById('specialEffect').value;
            const options = document.getElementById('effectOptions');
            const colorOptions = document.getElementById('colorBoostOptions');
            
            options.style.display = effect ? 'block' : 'none';
            colorOptions.style.display = effect === 'colorBoost' ? 'block' : 'none';
        }

        function createSkill() {
            const name = document.getElementById('skillName').value;
            if (!name) {
                alert('スキル名を入力してください');
                return;
            }

            const skill = {
                name: name,
                requiredCount: parseInt(document.getElementById('requiredCount').value),
                requiredColor: document.getElementById('requiredColor').value,
                clearType: document.getElementById('clearType').value,
                specialPanel: document.getElementById('specialPanel').value,
                specialEffect: document.getElementById('specialEffect').value,
                emoji: document.getElementById('skillEmoji').value || null
            };

            const iconFile = document.getElementById('skillIcon').files[0];
            if (iconFile) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    skill.iconUrl = e.target.result;
                    continueSkillCreation(skill);
                };
                reader.readAsDataURL(iconFile);
            } else {
                continueSkillCreation(skill);
            }
        }

        function continueSkillCreation(skill) {
            const cutsceneFile = document.getElementById('skillCutscene').files[0];
            if (cutsceneFile) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    skill.cutsceneUrl = e.target.result;
                    finishSkillCreation(skill);
                };
                reader.readAsDataURL(cutsceneFile);
            } else {
                finishSkillCreation(skill);
            }
        }

        function finishSkillCreation(skill) {
            if (skill.clearType === 'coordinates') {
                skill.clearCoordinates = getSelectedCoordinates('clearGrid');
            } else if (skill.clearType === 'color') {
                skill.clearColor = document.getElementById('clearColor').value;
                skill.clearColorCount = parseInt(document.getElementById('clearColorCount').value) || 0;
            } else if (skill.clearType === 'random') {
                skill.randomClearCount = parseInt(document.getElementById('randomClearCount').value) || 0;
            }

            skill.specialCoordinates = getSelectedCoordinates('specialGrid');

            if (skill.specialEffect) {
                skill.effectDuration = parseInt(document.getElementById('effectDuration').value);
                skill.effectValue = parseFloat(document.getElementById('effectValue').value);
                if (skill.specialEffect === 'colorBoost') {
                    skill.boostColor = document.getElementById('boostColor').value;
                }
            }

            gameState.skills.push(skill);
            saveData();
            updateSkillList();
            updateDeckList();
            updateSpecialPanelOptions();
            
            resetSkillForm();
            alert('スキルを作成しました！');
        }

        function editSkill(index) {
            const skill = gameState.skills[index];
            document.getElementById('skillFormTitle').textContent = 'スキル編集';
            document.getElementById('skillSubmitButton').textContent = 'スキル更新';
            document.getElementById('skillSubmitButton').onclick = () => updateSkill(index);
            
            document.getElementById('skillName').value = skill.name;
            document.getElementById('requiredCount').value = skill.requiredCount;
            document.getElementById('requiredColor').value = skill.requiredColor;
            document.getElementById('clearType').value = skill.clearType || 'none';
            document.getElementById('specialPanel').value = skill.specialPanel || '';
            document.getElementById('specialEffect').value = skill.specialEffect || '';
            
            if (skill.iconUrl) {
                document.getElementById('skillIconPreview').src = skill.iconUrl;
                document.getElementById('skillIconPreview').style.display = 'block';
            }
            if (skill.emoji) {
                document.getElementById('skillEmoji').value = skill.emoji;
            }
            if (skill.cutsceneUrl) {
                document.getElementById('skillCutscenePreview').src = skill.cutsceneUrl;
                document.getElementById('skillCutscenePreview').style.display = 'block';
            }
            
            if (skill.clearType === 'coordinates') {
                setSelectedCoordinates('clearGrid', skill.clearCoordinates);
            } else if (skill.clearType === 'color') {
                document.getElementById('clearColor').value = skill.clearColor;
                document.getElementById('clearColorCount').value = skill.clearColorCount;
            } else if (skill.clearType === 'random') {
                document.getElementById('randomClearCount').value = skill.randomClearCount;
            }
            
            setSelectedCoordinates('specialGrid', skill.specialCoordinates);
            
            if (skill.specialEffect) {
                document.getElementById('effectDuration').value = skill.effectDuration;
                document.getElementById('effectValue').value = skill.effectValue;
                if (skill.specialEffect === 'colorBoost') {
                    document.getElementById('boostColor').value = skill.boostColor;
                }
            }
            
            toggleClearOptions();
            toggleEffectOptions();
        }

        function updateSkill(index) {
            const skill = {
                name: document.getElementById('skillName').value,
                requiredCount: parseInt(document.getElementById('requiredCount').value),
                requiredColor: document.getElementById('requiredColor').value,
                clearType: document.getElementById('clearType').value,
                specialPanel: document.getElementById('specialPanel').value,
                specialEffect: document.getElementById('specialEffect').value,
                emoji: document.getElementById('skillEmoji').value || null
            };
            
            if (!skill.name) {
                alert('スキル名を入力してください');
                return;
            }
            
            const iconFile = document.getElementById('skillIcon').files[0];
            if (iconFile) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    skill.iconUrl = e.target.result;
                    continueUpdateSkill(skill, index);
                };
                reader.readAsDataURL(iconFile);
            } else {
                skill.iconUrl = gameState.skills[index].iconUrl;
                continueUpdateSkill(skill, index);
            }
        }

        function continueUpdateSkill(skill, index) {
            const cutsceneFile = document.getElementById('skillCutscene').files[0];
            if (cutsceneFile) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    skill.cutsceneUrl = e.target.result;
                    finishUpdateSkill(skill, index);
                };
                reader.readAsDataURL(cutsceneFile);
            } else {
                skill.cutsceneUrl = gameState.skills[index].cutsceneUrl;
                finishUpdateSkill(skill, index);
            }
        }

        function finishUpdateSkill(skill, index) {
            if (skill.clearType === 'coordinates') {
                skill.clearCoordinates = getSelectedCoordinates('clearGrid');
            } else if (skill.clearType === 'color') {
                skill.clearColor = document.getElementById('clearColor').value;
                skill.clearColorCount = parseInt(document.getElementById('clearColorCount').value) || 0;
            } else if (skill.clearType === 'random') {
                skill.randomClearCount = parseInt(document.getElementById('randomClearCount').value) || 0;
            }
            
            skill.specialCoordinates = getSelectedCoordinates('specialGrid');
            
            if (skill.specialEffect) {
                skill.effectDuration = parseInt(document.getElementById('effectDuration').value);
                skill.effectValue = parseFloat(document.getElementById('effectValue').value);
                if (skill.specialEffect === 'colorBoost') {
                    skill.boostColor = document.getElementById('boostColor').value;
                }
            }
            
            gameState.skills[index] = skill;
            gameState.activeDeck = gameState.activeDeck.map(s => s.name === skill.name ? skill : s);
            
            saveData();
            updateSkillList();
            updateDeckList();
            updateSkillButtons();
            
            resetSkillForm();
            alert('スキルを更新しました！');
        }

        function resetSkillForm() {
            document.getElementById('skillForm').reset();
            document.getElementById('skillFormTitle').textContent = 'スキル作成';
            document.getElementById('skillSubmitButton').textContent = 'スキル作成';
            document.getElementById('skillSubmitButton').onclick = createSkill;
            document.getElementById('skillIconPreview').style.display = 'none';
            document.getElementById('skillCutscenePreview').style.display = 'none';
            document.getElementById('skillEmoji').value = '';
            document.querySelectorAll('#clearGrid .grid-cell').forEach(cell => cell.classList.remove('selected'));
            document.querySelectorAll('#specialGrid .grid-cell').forEach(cell => cell.classList.remove('selected'));
            toggleClearOptions();
            toggleEffectOptions();
        }

        function createPanel() {
            const name = document.getElementById('panelName').value;
            if (!name) {
                alert('パネル名を入力してください');
                return;
            }

            const panel = {
                name: name,
                color: document.getElementById('panelColor').value,
                clearCoordinates: getSelectedCoordinates('panelClearGrid', true),
                emoji: document.getElementById('panelEmoji').value || '⭐'
            };

            const imageFile = document.getElementById('panelImage').files[0];
            if (imageFile) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    panel.imageUrl = e.target.result;
                    gameState.specialPanels.push(panel);
                    saveData();
                    updatePanelList();
                    updateSpecialPanelOptions();
                    resetPanelForm();
                    alert('特殊パネルを作成しました！');
                };
                reader.readAsDataURL(imageFile);
            } else {
                gameState.specialPanels.push(panel);
                saveData();
                updatePanelList();
                updateSpecialPanelOptions();
                resetPanelForm();
                alert('特殊パネルを作成しました！');
            }
        }

        function editPanel(index) {
            const panel = gameState.specialPanels[index];
            document.getElementById('panelFormTitle').textContent = '特殊パネル編集';
            document.getElementById('panelSubmitButton').textContent = 'パネル更新';
            document.getElementById('panelSubmitButton').onclick = () => updatePanel(index);
            
            document.getElementById('panelName').value = panel.name;
            document.getElementById('panelColor').value = panel.color;
            if (panel.imageUrl) {
                document.getElementById('panelImagePreview').src = panel.imageUrl;
                document.getElementById('panelImagePreview').style.display = 'block';
            }
            if (panel.emoji) {
                document.getElementById('panelEmoji').value = panel.emoji;
            }
            
            setSelectedCoordinates('panelClearGrid', panel.clearCoordinates, true);
        }

        function updatePanel(index) {
            const panel = {
                name: document.getElementById('panelName').value,
                color: document.getElementById('panelColor').value,
                clearCoordinates: getSelectedCoordinates('panelClearGrid', true),
                emoji: document.getElementById('panelEmoji').value || '⭐'
            };
            
            if (!panel.name) {
                alert('パネル名を入力してください');
                return;
            }
            
            const imageFile = document.getElementById('panelImage').files[0];
            if (imageFile) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    panel.imageUrl = e.target.result;
                    finishUpdatePanel(panel, index);
                };
                reader.readAsDataURL(imageFile);
            } else {
                panel.imageUrl = gameState.specialPanels[index].imageUrl;
                finishUpdatePanel(panel, index);
            }
        }

        function finishUpdatePanel(panel, index) {
            gameState.specialPanels[index] = panel;
            saveData();
            updatePanelList();
            updateSpecialPanelOptions();
            
            resetPanelForm();
            alert('特殊パネルを更新しました！');
        }

        function resetPanelForm() {
            document.getElementById('panelForm').reset();
            document.getElementById('panelFormTitle').textContent = '特殊パネル作成';
            document.getElementById('panelSubmitButton').textContent = 'パネル作成';
            document.getElementById('panelSubmitButton').onclick = createPanel;
            document.getElementById('panelImagePreview').style.display = 'none';
            document.getElementById('panelEmoji').value = '';
            document.querySelectorAll('#panelClearGrid .grid-cell').forEach(cell => cell.classList.remove('selected'));
        }

        function saveColorSettings() {
            const colors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange'];
            let pending = colors.length;
            let completed = 0;
            
            colors.forEach(color => {
                const input = document.getElementById(`color${color.charAt(0).toUpperCase() + color.slice(1)}Image`);
                const emojiInput = document.getElementById(`color${color.charAt(0).toUpperCase() + color.slice(1)}Emoji`);
                gameState.colorEmojis[color] = emojiInput.value || null;
                
                if (input.files && input.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        gameState.colorImages[color] = e.target.result;
                        completed++;
                        if (completed === pending) {
                            saveData();
                            updateDisplay();
                            updateColorForm();
                            alert('色設定を保存しました！');
                        }
                    };
                    reader.readAsDataURL(input.files[0]);
                } else {
                    completed++;
                    if (completed === pending) {
                        saveData();
                        updateDisplay();
                        updateColorForm();
                        alert('色設定を保存しました！');
                    }
                }
            });
        }

        function clearColorImage(color) {
            if (confirm(`${color}の画像を解除しますか？`)) {
                gameState.colorImages[color] = null;
                const preview = document.getElementById(`color${color.charAt(0).toUpperCase() + color.slice(1)}Preview`);
                preview.style.display = 'none';
                preview.src = '';
                saveData();
                updateDisplay();
                updateColorForm();
                alert(`${color}の画像を解除しました！`);
            }
        }

        function updateColorForm() {
            const colors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange'];
            colors.forEach(color => {
                const preview = document.getElementById(`color${color.charAt(0).toUpperCase() + color.slice(1)}Preview`);
                const emojiInput = document.getElementById(`color${color.charAt(0).toUpperCase() + color.slice(1)}Emoji`);
                if (gameState.colorImages[color]) {
                    preview.src = gameState.colorImages[color];
                    preview.style.display = 'block';
                } else {
                    preview.style.display = 'none';
                }
                emojiInput.value = gameState.colorEmojis[color] || '';
            });
        }

        function updateSkillList() {
            const list = document.getElementById('skillList');
            list.innerHTML = '';
            
            gameState.skills.forEach((skill, index) => {
                const div = document.createElement('div');
                div.className = 'skill-item';
                let effectText = skill.specialEffect ? 
                    (skill.specialEffect === 'scoreBoost' ? 
                        `スコア${skill.effectValue.toFixed(1)}倍(${skill.effectDuration}ターン)` :
                        `${skill.boostColor}出現率${skill.effectValue.toFixed(1)}倍(${skill.effectDuration}ターン)`) : 'なし';
                div.innerHTML = `
                    <strong>${skill.name}</strong><br>
                    <small>必要: ${skill.requiredColor} ${skill.requiredCount}個</small><br>
                    <small>効果: ${skill.clearType}</small><br>
                    <small>特殊効果: ${effectText}</small>
                    <button class="button" onclick="editSkill(${index})" style="float: right; padding: 2px 8px; margin-right: 5px;">編集</button>
                    <button class="button" onclick="deleteSkill(${index})" style="float: right; padding: 2px 8px;">削除</button>
                `;
                list.appendChild(div);
            });
        }

        function updatePanelList() {
            const list = document.getElementById('panelList');
            list.innerHTML = '';
            
            gameState.specialPanels.forEach((panel, index) => {
                const div = document.createElement('div');
                div.className = 'panel-item';
                div.innerHTML = `
                    <strong>${panel.name}</strong><br>
                    <small>色: ${panel.color}</small><br>
                    <small>消去範囲: ${panel.clearCoordinates.length}箇所</small>
                    <button class="button" onclick="editPanel(${index})" style="float: right; padding: 2px 8px; margin-right: 5px;">編集</button>
                    <button class="button" onclick="deletePanel(${index})" style="float: right; padding: 2px 8px;">削除</button>
                `;
                list.appendChild(div);
            });
        }

        function updateDeckList() {
            const list = document.getElementById('deckSkillList');
            list.innerHTML = '';
            
            gameState.skills.forEach((skill, index) => {
                const div = document.createElement('div');
                div.className = 'skill-item';
                const isSelected = gameState.activeDeck.some(s => s.name === skill.name);
                if (isSelected) div.classList.add('selected');
                
                let effectText = skill.specialEffect ? 
                    (skill.specialEffect === 'scoreBoost' ? 
                        `スコア${skill.effectValue.toFixed(1)}倍(${skill.effectDuration}ターン)` :
                        `${skill.boostColor}出現率${skill.effectValue.toFixed(1)}倍(${skill.effectDuration}ターン)`) : 'なし';
                div.innerHTML = `
                    <strong>${skill.name}</strong><br>
                    <small>必要: ${skill.requiredColor} ${skill.requiredCount}個</small><br>
                    <small>効果: ${skill.clearType}</small><br>
                    <small>特殊効果: ${effectText}</small>
                `;
                div.onclick = () => toggleDeckSkill(skill);
                list.appendChild(div);
            });
        }

        function toggleDeckSkill(skill) {
            const index = gameState.activeDeck.findIndex(s => s.name === skill.name);
            if (index !== -1) {
                gameState.activeDeck.splice(index, 1);
            } else if (gameState.activeDeck.length < 4) {
                gameState.activeDeck.push(skill);
            } else {
                alert('デッキには最大4つのスキルまで設定できます。');
                return;
            }
            updateDeckList();
            updateSkillButtons();
        }

        function saveDeck() {
            saveData();
            updateSkillButtons();
            alert('デッキを保存しました！');
        }

        function deleteSkill(index) {
            if (confirm('このスキルを削除しますか？')) {
                const skill = gameState.skills[index];
                gameState.skills.splice(index, 1);
                gameState.activeDeck = gameState.activeDeck.filter(s => s.name !== skill.name);
                saveData();
                updateSkillList();
                updateDeckList();
                updateSkillButtons();
            }
        }

        function deletePanel(index) {
            if (confirm('この特殊パネルを削除しますか？')) {
                const panel = gameState.specialPanels[index];
                gameState.specialPanels.splice(index, 1);
                gameState.skills.forEach(skill => {
                    if (skill.specialPanel === panel.name) {
                        skill.specialPanel = '';
                    }
                });
                gameState.activeDeck.forEach(skill => {
                    if (skill.specialPanel === panel.name) {
                        skill.specialPanel = '';
                    }
                });
                saveData();
                updatePanelList();
                updateSpecialPanelOptions();
                updateSkillList();
                updateDeckList();
            }
        }

        function updateSpecialPanelOptions() {
            const select = document.getElementById('specialPanel');
            const currentValue = select.value;
            select.innerHTML = `
                <option value="">なし</option>
                <option value="bomb">爆弾</option>
            `;
            
            gameState.specialPanels.forEach(panel => {
                const option = document.createElement('option');
                option.value = panel.name;
                option.textContent = panel.name;
                select.appendChild(option);
            });
            
            select.value = currentValue;
        }

        // handleSpecialPanelTapの修正：安定化と競合防止
        function handleSpecialPanelTap(x, y) {
            const panel = gameState.board[y][x];
            if (panel.type !== 'special' || !panel.clearPattern) {
                gameState.pendingActions.shift();
                processNextAction();
                return;
            }
            
            const toRemove = [];
            const processed = new Set();
            processed.add(`${x},${y}`);
            
            panel.clearPattern.forEach(({x: dx, y: dy}) => {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < 10 && ny >= 0 && ny < 10 && !processed.has(`${nx},${ny}`)) {
                    toRemove.push({x: nx, y: ny});
                    processed.add(`${nx},${ny}`);
                }
            });
            
            const removedColors = processRemovePanels(toRemove);
            
            setTimeout(() => {
                const baseScore = toRemove.length * 95;
                const bonusScore = Math.pow(toRemove.length, 1.2) * 5;
                const multiplier = gameState.specialEffects.scoreBoost ? gameState.specialEffects.scoreBoost.multiplier : 1;
                gameState.score += Math.floor((baseScore + bonusScore) * multiplier);
                
                Object.entries(removedColors).forEach(([color, count]) => {
                    updateSkillProgress(color, count);
                });
                
                updateSpecialEffects();
                
                setTimeout(() => {
                    dropPanels();
                    fillBoard();
                    gameState.pendingActions.shift();
                    processNextAction();
                }, 500);
            }, 300);
        }

        function saveData() {
            const data = {
                skills: gameState.skills.map(skill => ({
                    ...skill,
                    iconUrl: skill.iconUrl || null,
                    cutsceneUrl: skill.cutsceneUrl || null,
                    emoji: skill.emoji || null
                })),
                specialPanels: gameState.specialPanels.map(panel => ({
                    ...panel,
                    imageUrl: panel.imageUrl || null,
                    emoji: panel.emoji || null
                })),
                activeDeck: gameState.activeDeck.map(skill => ({
                    ...skill,
                    iconUrl: skill.iconUrl || null,
                    cutsceneUrl: skill.cutsceneUrl || null,
                    emoji: skill.emoji || null
                })),
                colorImages: gameState.colorImages,
                colorEmojis: gameState.colorEmojis
            };
            localStorage.setItem('customPuzzleData', JSON.stringify(data));
        }

        function loadData() {
            const data = localStorage.getItem('customPuzzleData');
            if (data) {
                const parsed = JSON.parse(data);
                gameState.skills = parsed.skills || [];
                gameState.specialPanels = parsed.specialPanels || [];
                gameState.activeDeck = parsed.activeDeck || [];
                gameState.colorImages = parsed.colorImages || {
                    red: null,
                    blue: null,
                    green: null,
                    yellow: null,
                    purple: null,
                    orange: null
                };
                gameState.colorEmojis = parsed.colorEmojis || {
                    red: null,
                    blue: null,
                    green: null,
                    yellow: null,
                    purple: null,
                    orange: null
                };
                updateSkillList();
                updatePanelList();
                updateDeckList();
                updateSpecialPanelOptions();
                updateColorForm();
            }
        }

        window.addEventListener('DOMContentLoaded', function() {
            initGame();
        });
    </script>
</body>
</html>
